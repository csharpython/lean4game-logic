{"∨ over ∧": "∨を∧まで",
 "∨ Tutorial: The Kraken": "∨ チュートリアル: クラーケン",
 "∧ over ∨": "∧を∨まで",
 "∧ Tutorial: Party Invites": "∧ チュートリアル: パーティーの招待",
 "↔ Tutorial: Party Games": "",
 "→ distributes over ∧": "→は∧に関し分配的",
 "→ Tutorial: Party Snacks": "→ チュートリアル: パーティーの軽食",
 "λs ↦ false_elim (h s)": "",
 "¬¬\\\"You bought this cake\"": "",
 "¬S is enough to show S → B": "",
 "¬Intro Boss": "",
 "¬A is stable.": "",
 "¬ Tutorial: Falsification": "",
 "repeat combinator": "繰り返しコンビネータ",
 "repeat assumption": "assumptionを繰り返す",
 "or distributes over and": "∨は∧に関し分配的",
 "not_not_not": "",
 "not not introduction.": "",
 "level completed! 🎉": "レベルコンプリート！ 🎉",
 "level completed with warnings… 🎭": "レベルクリア、ただし警告があります... 🎭",
 "intermediate goal solved! 🎉": "中間ゴール　クリア🎉",
 "h.left.right.left.left.right": "",
 "exact and_intro «{ai}» «{ou}»": "",
 "exact and_intro p s": "",
 "contradiction closes the current goal there are assumptions which are \"trivially contradictory\".\r\n\r\n### Example\r\n```\r\nAssumptions:\r\nh : False\r\n```\r\n### Example\r\n```\r\nAssumptions:\r\nh₁ : P\r\nh₂ : ¬P\r\n```":
 "",
 "assumption tries to solve the main goal by searching your the assumptions in your proof state for a hypothesis with a compatible proposition":
 "assumptionは、証明状態にある仮定を検索して、適合する命題を持つ仮説を探すことによって、主目標を解決しようとします",
 "and_intro, and_left, and_right": "",
 "and_imp 2": "and_imp 2",
 "and_imp": "and_imp",
 "and distributes over or": "∧は∨に関し分配的",
 "`λ h : I ∧ S ↦ and_intro (and_right h) h.left`": "`λ h : I ∧ S ↦ and_intro (and_right h) h.left`",
 "`or_elim h₃ ... ...`": "`or_elim h₃ ... ...`",
 "`identity`": "",
 "`exact h.right`": "",
 "`cases h3`": "`cases h3`",
 "```\r\nrw [or_assoc]\r\nrw [and_assoc]\r\nexact h\r\n```\r\n----\r\n```\r\nrw [or_assoc, and_assoc]\r\nexact h\r\n```\r\n----\r\nWithout the `rw` tactic\r\n```\r\nexact or_assoc.mp ≫ h ≫ imp_trans and_assoc.mp\r\n```":
 "",
 "`Q → (P → Q) ∧ (¬P → Q)`": "`Q → (P → Q) ∧ (¬P → Q)`",
 "`P → (P → Q) → Q`": "`P → (P → Q) → Q`",
 "`(P → Q) ∧ (P → R) → P → Q ∧ R`": "`(P → Q) ∧ (P → R) → P → Q ∧ R`",
 "`(P → Q → R) → P ∧ Q → R`": "`(P → Q → R) → P ∧ Q → R`",
 "You've made use of the concept that \"false implies anything\".\r\n\r\n----\r\n```\r\nh           : S     → False\r\nfalse_elim  : False → B\r\n```\r\nBecause the righthand side of `h` and the lefthand side of `false_elim` match, you can use `imp_trans` to combine these:\r\n```\r\nimp_trans h false_elim\r\n```":
 "",
 "You've made use of the concept that \"false implies anything\".": "",
 "You've got evidence that Pippin and Sybeth are invited to the party.\\\r\n\\\r\nHere are some answers the game would have accepted:\r\n```\r\nexact and_intro p s\r\nexact ⟨p,s⟩\r\n```":
 "PippinとSybethがパーティーに招待されている証拠を得ました。\r\n\r\n以下は、ゲームが受け入れるであろう答えです：\r\n```\r\nexact and_intro p s\r\nexact ⟨p,s⟩\r\n```",
 "You've got a proof that Pippin is coming to the party! Lets see if Cyna will attend as well.\r\n\r\n----\r\nA reminder that expressions work with the `have` and `exact` tactics in much the same way. You can also solve this level without `have`.\r\n```lean\r\nexact vm.left\r\n```":
 "Pippinがパーティに来るという証拠を手に入れた！Cynaも参加するか見てみましょう。\r\n\r\n----\r\n式は `have` と `exact`のタクティクではほとんど同じように動作することを忘れないでください。あなたはこのレベルを`have`を使わずに解けます。\r\n```lean\r\nexact vm.left\r\n```",
 "You're very convincing, and now Sybeth can see that if Riffin is bringing a snack, he'll be bringing it regardless of what she does.\\\r\n\\\r\nOn to the next world!\r\n\r\n----\r\n# Hint\r\nIf you're not going to use some evidence, then you don't need to name it. You can write an underscore as a placeholder. For example, my solution looked like this:\r\n```\r\nexact λ r : R ↦ ⟨λ _ : S ↦ r, λ _ : ¬S ↦ r⟩\r\n-- which can be abbreviated\r\nexact λr ↦ ⟨λ_ ↦ r, λ_ ↦ r⟩\r\n```":
 "あなたは非常に説得力があります。そして、SybethはRiffinがスナックを持ってくるなら、彼女が何をしようが、彼は必ず持ってくることに気づきました。\r\n\r\n次のワールドへ！\r\n\r\n----\r\n# ヒント\r\nある証拠を使わない場合、その名前を書く必要はありません。プレースホルダーとしてアンダーバーを使えます。例えば、私の解法はこう見える：\r\n```\r\nexact λ r : R ↦ ⟨λ _ : S ↦ r, λ _ : ¬S ↦ r⟩\r\n-- こう略せる\r\nexact λr ↦ ⟨λ_ ↦ r, λ_ ↦ r⟩\r\n```",
 "You'll never **actually** find evidence for `False`, but evidence for `¬False` is a very simple tautology, as you would expect.\r\n\r\n----\r\nWhich Proof did you use?\r\n```\r\nexact identity\r\nexact λ(f : False) ↦ f\r\nexact λf ↦ f\r\n```":
 "",
 "You definitely have a knack for providing conditional arguments!": "あなたは条件付き命題の展開が本当に上手ですね！",
 "Write the necessary nested function(s)!": "必要なネストされた関数を作ろう！",
 "Who is loyal, who is a spy?": "",
 "Well, done.\r\n\r\n---\r\n```\r\nexact or_elim h or_inr or_inl\r\n```": "よくやった。\r\n\r\n---\r\n```\r\nexact or_elim h or_inr or_inl\r\n```",
 "Well reasoned": "",
 "Well done, you're getting good at this!": "よくやった、上手くなってきたね！",
 "Well Concluded!": "",
 "Use the constructor tactic": "タクティク「constructor」を使う",
 "Use the assumption tactic": "タクティク「assumption」を使う",
 "Uncertain Snacks": "不確かなスナック",
 "Three × and_intro.": "3 × and_intro",
 "This set of tactic-based levels is complete!\r\n\r\n------\r\n```\r\nintro\r\nconstructor\r\nrepeat {intro; assumption}\r\n```":
 "このタクティクベースのレベルセット、完了！\r\n\r\n------\r\n```\r\nintro\r\nconstructor\r\nrepeat {intro; assumption}\r\n```",
 "This says nothing about whether or not oranges are a vegetable. All we know is that at least one of `O` or `S` must be true.":
 "これはオレンジが野菜かどうかについて何も言っていません。私たちが知っているのは、`O`と`S`の少なくとも1つが真であるということです。",
 "This one takes a while": "",
 "This joke is a reach, I know, but my answer in this level kinda spells `ahaa` — `λa ↦ h a a`. \\\r\n\\\r\nOkay, okay. Let's proceed.":
 "",
 "This is a great example of how the infix `imp_trans` operator can streamline a level:\r\n\r\n---\r\n```lean\r\nhave g := h.left\r\nexact or_elim h.right\r\n  (and_intro g ≫ or_inl)\r\n  (and_intro g ≫ or_inr)\r\n```":
 "これは、中置演算子`imp_trans`がどうやってレベルを合理化できるか示すよい例です：\r\n\r\n---\r\n```lean\r\nhave g := h.left\r\nexact or_elim h.right\r\n  (and_intro g ≫ or_inl)\r\n  (and_intro g ≫ or_inr)\r\n```",
 "Think before you act :)": "動く前に考えよう :)",
 "These unintuitive statements highlight the inherent challenge in contemplating the *potential* existence (or definite non-existence) of implications.\r\n\r\nThat's a twist of logic, to be sure!":
 "",
 "The law of non-self-contradiction": "",
 "The bakery guy, upon reviewing your evidence, exclaims, \"Amazing! I never knew this. With this added knowledge, I'll be able to bake your cake!\"\r\n\r\n----\r\nIn this level, as your goal is `I ∧ S → S ∧ I`, the game automatically recognizes the evidence you're assuming. You don't need to explicitly write it out. Therefore, you can use the following alternatives:\r\n```\r\nfun h => and_intro (and_right h) (and_left h)\r\nfun h => and_intro h.right h.left\r\n-- or with Unicode\r\nλh ↦ ⟨h.right, h.left⟩\r\n```":
"パン屋の店主は、あなたの証拠を確認した後、驚いて「すごい！そんなこと知らなかった！この追加の知識があれば、あなたのケーキを焼くことができます！」と叫びました。\r\n\r\n----\r\nこのレベルでは、あなたのゴールが `I ∧ S → S ∧ I` であるため、ゲームはあなたが仮定している証拠を自動的に認識します。明示的に書く必要はありません。したがって、以下の代替手段を使えます。:\r\n```\r\nfun h => and_intro (and_right h) (and_left h)\r\nfun h => and_intro h.right h.left\r\n-- もしくはUnicodeで\r\nλh ↦ ⟨h.right, h.left⟩\r\n```",
 "The Implication": "含意",
 "The Have Tactic": "タクティク「have」",
 "That's settled... again!\r\n\r\n----\r\nReminder that these are the same:\r\n```\r\nλp ↦ λa ↦ h ⟨p,a⟩\r\n-- and\r\nλp a ↦ h ⟨p,a⟩\r\n```":
 "",
 "That's settled": "",
 "That's better, but you'd better send out those invites so you can get some responses!\r\n\r\n----\r\n```\r\nhave a := h1.left\r\nhave u := h2.right\r\nexact and_intro a u\r\n```\r\n---\r\n```\r\nexact and_intro h1.left h2.right\r\n```\r\n----\r\n```\r\nexact and_intro (and_left h1) (and_right h2)\r\n```\r\n---\r\n```\r\nexact ⟨h1.left, h2.right⟩\r\n```":
 "これでいいと思うけど、招待状を送って反応を見たほうがいいよ！\r\n\r\n----\r\n```\r\nhave a := h1.left\r\nhave u := h2.right\r\nexact and_intro a u\r\n```\r\n---\r\n```\r\nexact and_intro h1.left h2.right\r\n```\r\n----\r\n```\r\nexact and_intro (and_left h1) (and_right h2)\r\n```\r\n---\r\n```\r\nexact ⟨h1.left, h2.right⟩\r\n```",
 "Take apart and build evidence": "証拠を分解し、構築する",
 "Swapping": "交換",
 "Statement": "",
 "Show ¬(P ∧ A)": "",
 "Show that ∧ is commutative": "∧の可換性を示す",
 "Show that → is transitive": "→の推移性を示す",
 "Show P → ¬A.": "",
 "Self Contradictory 2": "",
 "Self Contradictory": "",
 "Rinse and Repeat": "繰り返し",
 "Right Evidence": "右の証拠",
 "Riffin is bringing a unicorn snack": "Riffinがユニコーンのスナックを持ってくる",
 "Riffin Snacks": "Riffinのスナック",
 "Rewriting": "",
 "Repeat constructor/assumption until you're done": "完了するまでconstructor／assumptionを繰り返す",
 "Remember `h: P → ¬P` is actually `h : P → P → False`": "",
 "Remember `h : A → A → False`": "",
 "Redux: ∨ World Tactics": "再開：∨ タクティクの世界",
 "Redux: ∧ World Tactics": "再開：∧ タクティクの世界",
 "Redux: ↔ World Tactics": "",
 "Redux: → World Tactics": "再開：→ タクティクの世界",
 "Redux: ¬ World Tactics": "",
 "Rearranging Boxes": "箱の並べ替え",
 "Practise Makes Perfect": "習うより慣れろ",
 "Phew, that makes perfect sense now.": "",
 "P and Q implies P": "「PかつQ」はPを包含する",
 "Or is Commutative": "「または」は可換",
 "Or Introduction Right": "「または」の導入則・右",
 "Or Introduction Left": "「または」の導入則・左",
 "Or Elimination": "「または」の除去則",
 "Onward and upward\r\n\r\n----\r\n```\r\nexact iff_intro hsj hjs\r\n```\r\n---\r\n```\r\nexact ⟨hsj, hjs⟩\r\n```":
 "",
 "Once you've gathered evidence confirming that the object is a cake, the game becomes straightforward. The show's appeal lies not in the simple truism that a cake is a cake but rather in the contestants' skill to compile credible evidence. Typically, the most compelling evidence is presented by the host when he cuts into the object, unveiling its contents.\r\n\r\n----\r\n# A Tip\r\nMoreover, since the goal already specifies the expected type of evidence, you can streamline your function without explicitly writing out the assumed proposition.\r\n```\r\nexact λ(h : C) ↦ h\r\n-- can be written\r\nexact λh ↦ h\r\n```":
 "ケーキであることを確認する証拠を集めたら、ゲームは単純になります。この番組の魅力は、「ケーキはケーキだ」という単純な決まり文句にあるのではなく、出場者たちが信頼できる証拠をまとめる技術にあります。通常、最も説得力のある証拠は、ホストが対象物に切り込みを入れて中身を見せるときに披露されます。\r\n\r\n----\r\n# A Tip\r\nさらに、ゴールはすでに想定される証拠の型を指定しているので、想定される命題を明示的に書き出すことなく、関数を合理化することができます。\r\n```\r\nexact λ(h : C) ↦ h\r\n-- こう書ける\r\nexact λh ↦ h\r\n```",
 "Old Hat": "おなじみの",
 "Okay, that was a bit easy for a boss level. Don't sweat it, just enjoy the icecream!":
 "ボス戦にしては簡単だったかな。気にすんな、アイスクリームを楽しもう！",
 "Oh, how nice! A fast solution to a complex problem.\r\n\r\n----\r\nIf you've read the inventory page for `rw`, you may have seen another solution too. You can use the backwards arrow “`←`” to change `P`s to `L`s instead of `L`s to `P`s. Also, you can change a hypothesis instead of the goal.\r\n```\r\nrw [← h₁] at h₂\r\nexact h₂\r\n```\r\n\r\nHere's an example of what this looks like without the `rw` tactic — if you want to try this solution, copy & paste the following text to the editor input mode.\r\n```\r\nexact ⟨\r\n  λh₃ ↦ have ⟨a,c,np⟩ := h₂.mp (\r\n    λh₄ ↦ h₃ (λ⟨hl₅,hr₅⟩ l ↦ h₄ ⟨\r\n      λa ↦ or_elim\r\n        (hl₅ a)\r\n        or_inl\r\n        (imp_trans h₁.mpr ≫ or_inr)\r\n    ,\r\n      λ_ ↦ hr₅ (or_inl l)\r\n    ⟩ (h₁.mp l))\r\n  )\r\n  ⟨a, c, h₁.mp ≫ np⟩\r\n,\r\n  λ⟨a,c,nl⟩ _ ↦ false_elim (\r\n    h₂.mpr\r\n      ⟨a, c, h₁.mpr ≫ nl⟩\r\n      λ_ _ ↦ c\r\n  )\r\n⟩\r\n```\r\nThe thing to notice here is that this long-form solution needs both `h₁.mp` and `h₁.mpr`. Keep in mind that though it’s often tempting to try to use conditionals (`→`), rewrite **requires** a biconditional (`↔`) to work.":
 "",
 "Nothing New": "新しいことはない",
 "Not Tactics Boss": "",
 "Not False": "",
 "Nice. Onward!\r\n\r\n----\r\n```\r\nexact h.right\r\n```\r\n----\r\n```\r\nexact and_right h\r\n```":
 "いいね。前進だ！\r\n\r\n----\r\n```\r\nexact h.right\r\n```\r\n----\r\n```\r\nexact and_right h\r\n```",
 "Nested `λ↦`s.": "",
 "Negation into conjunction.": "",
 "Negation": "",
 "Negated Conjunction": "",
 "Navigate the tree": "ツリーのナビゲーション",
 "More Elimination": "もっと除去を",
 "More Cases": "もっとcasesを",
 "Modus Tollens.": "",
 "Modus Tollens": "",
 "Mix and Match": "混ぜて合わせて",
 "Might it possibly still be filled with chocolate chips? That sounds absolutely delightful!":
 "",
 "Left Evidence": "左の証拠",
 "Lean intro to Logic": "",
 "Just like before, you need to keep in mind that `¬P` is defined as `P → False`.\\\r\n\\\r\n∴ `¬False` is actually asking for `False → False`":
 "",
 "In this game, the deductive rule *modus_ponens* is just function application.\r\n```\r\nintro h : A ∧ B\r\nhave a : A := and_left h\r\n-- could be written as\r\nhave a : A := modus_ponens and_left h\r\n```\r\nand\r\n```\r\nintro a : A\r\nintro b : B\r\nhave h : A ∧ B := and_intro a b\r\n-- could be written as\r\nhave h : A ∧ B := modus_ponens (modus_ponens and_intro a) b\r\n```\r\n\r\nYou should never use this style of prefix `modus_ponens` and just use function application instead as that will generally be clearer.\r\n\r\n----\r\n# Infix Modus Ponens\r\nThere is are infix operators for function application; they look like `|>` and `<|`. `f <| x`, and `x |> f` means the same as the same as `f x`.\r\n\r\n`<|` parses `x` with lower precedence, which means that `f <| g $ <|` is interpreted as `(f (g x))` rather than `((f g) x)`.\r\n\r\nIt's twin, `|>` chains such that `x |> f |> g` is interpreted as `g (f x)`.\r\n\r\nWhat makes the infix operators useful is that they can often replace a pair of brackets `(...)` making expressions easier to read.\r\n\r\n----\r\n# Computer Science\r\nIf you've done some programming before, you might recognise `Modus Ponens` as the identity function for implications. So `(modus_ponens and_left)` is extensionally equal to `and_left`. There's a conspiracy at work here!":
 "このゲームでは、演繹規則*modus_ponens*は、単なる関数適用である。\r\n```\r\nintro h : A ∧ B\r\nhave a : A := and_left h\r\n-- 次のようにも書ける\r\nhave a : A := modus_ponens and_left h\r\n```\r\nあるいは\r\n```\r\nintro a : A\r\nintro b : B\r\nhave h : A ∧ B := and_intro a b\r\n-- 次のようにも書ける\r\nhave h : A ∧ B := modus_ponens (modus_ponens and_intro a) b\r\n```\r\n\r\nこの形式の接頭辞 `modus_ponens` は決して使うべきでなく、代わりに関数適用を使うのが一般的である。\r\n\r\n----\r\n# 接中辞のモーダス・ポネンス\r\nここには関数適用の接中辞がある：それらは`|>`や`<|`のように見える。`f <| x`と`x |> f`は`f x`と同じ意味である。\r\n\r\n`<|` は`x` を低い優先順位で解析する。つまり、`f <| g <| x` は `((f g) x)`ではなく `(f (g x))` と解釈される。\r\n\r\n`|>`の連鎖は双子のようなもので、`x |> f |> g`は`g (f x)`と解釈される。\r\n\r\nこの接中辞演算子が便利な点は、2つの括弧 `(...)` を置き換えることで、式を読みやすくすることができる所だ。\r\n\r\n----\r\n# コンピューターサイエンス\r\nプログラミングをやったことがある人なら、`modus_ponens`が含意の恒等関数であることに気づくかもしれない。つまり、`(modus_ponens and_left)`は拡張的に`and_left`と等しい。ここには陰謀が働いている！",
 "Implies a Negation": "",
 "Implication of ∨": "∨の含意",
 "Implication across ∨": "∨を跨ぐ含意",
 "Implication Tactic Boss": "「含意」　タクティク　ボス",
 "Iff_mp": "",
 "Iff_Intro": "",
 "IffBoss": "",
 "If you have an assumption like `h : P ↔ Q`, then\r\n```\r\niff_mp h -- or\r\nh.mp     -- is evidence for P → Q\r\n\r\niff_mpr h -- or\r\nh.mpr     -- is evidence for Q → P\r\n```":
 "",
 "If\r\n```\r\n-- Assumptions\r\nh : False\r\n```\r\nthen\r\n```\r\nhave t : T := false_elim h\r\n```\r\nwill allow you to write any well formed proposition in place of `T`. This makes `false_elim` the \\\"From `False`, anything goes\\\" function. **Ex falso quodlibet**.":
 "",
 "Identity": "恒等",
 "Idenity via tactics": "タクティクによる恒等性",
 "Great! Another 4 invites sent out. You're getting the hang of this.": "素晴らしい！また4通の招待状を送りました。コツをつかんだようですね。",
 "Go Right": "右へ行け",
 "Go Left": "左へ行け",
 "Fill a box, label correctly": "箱を埋め、正しくラベル付けする",
 "False implies anything": "",
 "Exhibit evidence that you're planning a party.": "「パーティを計画している」という証拠を示してください。",
 "Exhibit evidence that cake will be delivered to the party": "ケーキがパーティーに届けられるという証拠を示す",
 "Exhibit evidence that Pippin is coming to the party.": "Pippinがパーティーに来ているという証拠を示してください。",
 "Exactly! It's in the premise": "その通り！それは前提にある",
 "Exactly 2 rewrites": "",
 "Double False!": "",
 "Double False": "",
 "Distribute": "分配",
 "Did you use `intro ⟨p, a⟩` this time?": "",
 "Cool. Chips and Dip!\r\n\r\n----\r\n# A Tip!\r\nIf you're writing a function with more than one parameter, you can just list the parameters. That's a shorthand for nested function declarations.\r\n```\r\nλ(p : P) ↦ λ(q : Q) ↦ h (and_intro p q)\r\n-- can be written as:\r\nλ(p : P)(q : Q) ↦ h (and_intro p q)\r\n-- Or because the propositions of p and\r\n-- q are clear from the goal:\r\nλp q ↦ h (and_intro p q)\r\n```":
 "クール。チップスとディップ！\r\n\r\n----\r\n# ヒント！\r\n複数のパラメーターを持つ関数を書く場合、単にパラメーターを列挙するだけで済みます。 これは、ネストされた関数宣言の省略形です。\r\n```\r\nλ(p : P) ↦ λ(q : Q) ↦ h (and_intro p q)\r\n-- こう書ける：\r\nλ(p : P)(q : Q) ↦ h (and_intro p q)\r\n-- あるいは命題pと\r\n--命題qがゴールから明らかに分かるから：\r\nλp q ↦ h (and_intro p q)\r\n```",
 "Cool. Chips and Dip for sure!": "クール。チップスとディップは絶対！",
 "Contradiction": "",
 "Constructor": "コンストラクタ",
 "Conjunctive Iff": "",
 "Conjunction interacting with implication": "含意と相互作用する論理積",
 "Conjunction Implication": "",
 "Congratulations. You have evidence that your party will have cake!\r\n\r\n----\r\n1:\r\n```\r\nhave c := bakery_service p\r\nexact c\r\n```\r\n2:\r\n```\r\nexact bakery_service p\r\n```\r\n3:\r\n```\r\nexact modus_ponens bakery_service p\r\n```":
 "おめでとう。あなたのパーティーにはケーキがあるという証拠だ！\r\n\r\n----\r\n1:\r\n```\r\nhave c := bakery_service p\r\nexact c\r\n```\r\n2:\r\n```\r\nexact bakery_service p\r\n```\r\n3:\r\n```\r\nexact modus_ponens bakery_service p\r\n```",
 "Congratulations. Did you recognise this proof? It's actually a slightly less general version of the proof you used in the \"**→ Tutotial world, level 4**\" to show that implication is transitive.\r\n\r\n---\r\nThinking of `h₂` as `Q → False`, you can actually use your imp_trans theorem here.\r\n```\r\nexact λp ↦ h₂ (h₁ p)\r\n```\r\n```\r\nexact imp_trans h₁ h₂\r\n```\r\nFor the math-inclined, because the expression for an implication is a function, you can also use function composition.\r\n```\r\nexact h₂ ∘ h₁\r\n```":
 "",
 "Congratulations, not only have you started your todo list, you've learned how to exhibit the list as evidence that you've started planning the party.":
 "おめでとう、あなたはTodoリストを始めただけでなく、「あなたはパーティーの計画を立て始めた」という証拠としてのリストを示す方法を学びました。",
 "Commutativity of “`∨`”": "“`∨`”の可換性",
 "Commutativity of \"`∨`\"": "\"`∨`\"の可換性",
 "Common! Cake is Cake": "共通！ケーキはケーキ",
 "Combining your new tactics": "新しいタクティクを組み合わせる",
 "Change the goal to `False`. This is only helpful when there are assumptions which are in some way contradictory.\r\n### Example\r\n```\r\nAssumptions\r\nh : P ∧ ¬P\r\nGoal: Q\r\n```\r\nI cannot show evidence for `Q` directly, but because `False → Q` is trivially true (False implies anything), I can use the tactic `exfalso` which changes the Goal:\r\n```\r\nAssumptions\r\nh : P ∧ ¬P\r\nGoal: Q\r\n```\r\nAfter which `exact h.right r.left` meets the current goal.\r\n### Apply\r\n`exfalso` is the same as `apply false_elim`.\r\n∴ to show `Q` by `False → Q`, it suffices to show `False`.":
 "",
 "Chain Reasoning": "連鎖的推論",
 "Cases for a Conjunction": "論理積のケース",
 "Carry On Effects": "継続的効果",
 "Cake Form Swap": "ケーキの形の交換",
 "Cake Delivery Service": "ケーキ配達サービス",
 "Both P and Q entails just Q as well!": "「PかつQ」は、Qも伴っている！",
 "Assumption": "仮定",
 "As proof terms start getting bigger, it makes more sense to use Editor mode instead of typewritter mode.\r\n\r\n----\r\n```\r\nexact or_elim h\r\n  (λg ↦ ⟨or_inl g, or_inl g⟩)\r\n  (λhu ↦ ⟨or_inr hu.left, or_inr hu.right⟩)\r\n```\r\nYou can split this up a bit, but you'll need to write out a lot of propositions in full.\r\n```\r\n-- the case for g\r\nhave fg : G → (G ∨ H) ∧ (G ∨ U) :=\r\n    λg ↦ ⟨or_inl g, or_inl g⟩\r\n\r\n-- the case for H ∧ U\r\nhave fhu : H ∧ U → (G ∨ H) ∧ (G ∨ U) :=\r\n    λhu ↦ ⟨or_inr hu.left, or_inr hu.right⟩\r\n\r\n-- Finish it out with or_elim\r\nexact or_elim h fg fhu\r\n```":
 "証明項が大きくなり始めたため、タイプライターモードではなくエディターモードを使う方が理にかなっています。\r\n\r\n----\r\n```\r\nexact or_elim h\r\n  (λg ↦ ⟨or_inl g, or_inl g⟩)\r\n  (λhu ↦ ⟨or_inr hu.left, or_inr hu.right⟩)\r\n```\r\nこれは少し分割できますが、多くの命題を完全に書く必要があります。\r\n```\r\n-- Gの場合\r\nhave fg : G → (G ∨ H) ∧ (G ∨ U) :=\r\n    λg ↦ ⟨or_inl g, or_inl g⟩\r\n\r\n-- H ∧ Uの場合\r\nhave fhu : H ∧ U → (G ∨ H) ∧ (G ∨ U) :=\r\n    λhu ↦ ⟨or_inr hu.left, or_inr hu.right⟩\r\n\r\n-- or_elimで仕上げる\r\nexact or_elim h fg fhu\r\n```",
 "Apply Chain Reasoning": "連鎖的適用",
 "Apply Backwards": "逆方向の適用",
 "Apply": "適用",
 "Another One": "もう一つ",
 "And Tactic Boss": "「かつ」　タクティク　ボス",
 "And Introduction": "「かつ」の導入則",
 "And Elimination 2": "「かつ」の除去則 2",
 "And Elimination": "「かつ」の除去則",
 "Amazing! You've mastered \"AND\".\r\n\r\n---\r\n```\r\n-- 3/4 of the things you need are one step away\r\nhave psa := h.left\r\n\r\n-- Evidence for C takes some digging\r\nhave c := h.right.right.left.left\r\n\r\n-- build C ∧ P ∧ S\r\nhave cps := and_intro c psa.left\r\n\r\n-- exibit A ∧ C ∧ P ∧ S\r\nexact and_intro psa.right cps\r\n```":
 "すごい！あなたは「かつ」をマスターしたね。\r\n\r\n---\r\n```\r\n-- 必要なものの3/4は1ステップで手に入る\r\nhave psa := h.left\r\n\r\n-- Cの証拠には掘り下げが必要\r\nhave c := h.right.right.left.left\r\n\r\n-- C ∧ P ∧ Sを造る\r\nhave cps := and_intro c psa.left\r\n\r\n-- A ∧ C ∧ P ∧ Sを示す\r\nexact and_intro psa.right cps\r\n```",
 "Amazing! You've helped save your cat!\r\n\r\n----\r\nHere are three solutions, are you able to follow each of them?\r\n```\r\nhave h₁ := and_left h\r\nhave h₂ := and_right h₁\r\nhave h₃ := and_left h₂\r\nhave h₄ := and_left h₃\r\nhave h₅ := and_right h₄\r\nexact h₅\r\n```\r\nor\r\n```\r\nexact and_right (and_left (and_left (and_right (and_left h))))\r\n```\r\nor\r\n```\r\nexact h.left.right.left.left.right\r\n```":
 "いいね！あなたはあなたの猫を助けました！\r\n\r\n----\r\nここに3つの解決策があります、それぞれ従うことができますか？\r\n```\r\nhave h₁ := and_left h\r\nhave h₂ := and_right h₁\r\nhave h₃ := and_left h₂\r\nhave h₄ := and_left h₃\r\nhave h₅ := and_right h₄\r\nexact h₅\r\n```\r\nor\r\n```\r\nexact and_right (and_left (and_left (and_right (and_left h))))\r\n```\r\nor\r\n```\r\nexact h.left.right.left.left.right\r\n```",
 "Amazing! You've beaten the `∧` world a second time and you've learned some extra tactics in the process.":
 "よくやった！あなたは2番目の`∧`ワールドを制し、その過程でさらなるタクティクを学んだ。",
 "Amazing! He is bringing a snack and you have evidence to prove it too!\r\n\r\n----\r\nHere are two solutions to Riffin's puzzle. Sometimes it's helpful to see the same puzzles solved in more than one way.\r\n```\r\nhave q := h₁ p\r\nhave t := h₃ q\r\nhave u := h₅ t\r\nexact u\r\n```\r\nor nest them together:\r\n```\r\nexact h₅ (h₃ (h₁ p))\r\n```\r\nor use the `imp_trans` theorem from the previous world:\r\n```\r\nhave hpt := imp_trans h₁ h₃\r\nhave hpu := imp_trans hpt h₅\r\nexact hpu p\r\n```\r\nor if you've seen the infix operator for `imp_trans`:\r\n```\r\nexact (h₁ ≫ h₃ ≫ h₅) p\r\n```":
 "すごい！彼はスナックを持ってきたし、あなたにもそれを証明する証拠があります！\r\n\r\n----\r\n以下はRiffinのパズルに対する2つの解決策です。同じパズルを複数の方法で解くのを見ることは、時々役立ちます。\r\n```\r\nhave q := h₁ p\r\nhave t := h₃ q\r\nhave u := h₅ t\r\nexact u\r\n```\r\nあるいは、これをネストさせて：\r\n```\r\nexact h₅ (h₃ (h₁ p))\r\n```\r\nあるいは、前のワールドの定理`imp_trans`を使って：\r\n```\r\nhave hpt := imp_trans h₁ h₃\r\nhave hpu := imp_trans hpt h₅\r\nexact hpu p\r\n```\r\n あるいは、`imp_trans`の接中辞演算子を使って：\r\n```\r\nexact (h₁ ≫ h₃ ≫ h₅) p\r\n```",
 "Almost a repeat of level 1. That was fast.\r\n\r\nYou'll notice that last time you showed evidence for a proposition involving “Oranges are a vegetable” even though you probably know that oranges are a fruit and not a vegetable. This time you did the same for “sprinkles are super colourful,” which you probably know is true.\r\n\r\nWhat this demonstrates is that `∨` is an inclusive “or”, which means at least one of the propositions is true. It could be both or just one.":
 "",
 "Alarfil": "Alarfil",
 "AH ha! Well done.\r\n\r\n----\r\nFor the math-inclined, because the expression for an implication is a function, you can also use function composition.\r\n```\r\nexact h₂ ∘ h₁\r\n```":
 "ああ！よくやった。\r\n\r\n----\r\n数学に精通している方へ：含意の式は関数であるため、関数合成も使えます。\r\n```\r\nexact h₂ ∘ h₁\r\n```",
 "A mostly self-contained introduction to constructive logic using Lean. Learn how each propositional connective can be introduced and eliminated using both terms and tactics.":
 "",
 "A Lean Intro to Logic": "",
 "*Game version: 0.1.0*\r\n\r\n# Discussion\r\n\r\nThis game is currently in its initial development phase, designed to be largely self-contained and accessible without requiring a programming or math background to navigate. Feedback about meeting that goal is welcome!\r\n\r\nWhile self-contained; in many ways, this game is targeted more at programmers than mathematicians. It doesn't use classical reasoning, sticking instead to constructive logic. The emphasis for most of the theorem proving is on writing proof terms — rather than using tactics.\r\n\r\nPlease feel encouraged to visit the game's GitHub repository and initiate a discussion on any topic regarding this game. Just open a new issue or comment on an existing one.\r\nGithub: [A Lean Intro to Logic](https://github.com/Trequetrum/lean4game-logic)\r\n\r\n## Progress saving\r\n\r\nThe game stores your progress in your local browser storage.\r\nIf you delete it, your progress will be lost!\r\n\r\nWarning: In most browsers, deleting cookies will also clear the local storage\r\n(or \"local site data\"). Make sure to download your game progress first!\r\n\r\n## Credits\r\n\r\n* **Game Author:** Mark Fischer\r\n* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\r\n\r\n## Resources\r\n\r\n* The [Lean Zulip chat](https://leanprover.zulipchat.com/) forum\r\n* Github: [A Lean Intro to Logic](https://github.com/Trequetrum/lean4game-logic)":
 "",
 "### **Logic Constants & Operators**\r\n| $Name~~~$ | $Ascii~~~$ | $Unicode$ | $Unicode Cmd$ |\r\n| --- | :---: | :---: | --- |\r\n| True | `True` |  |  |\r\n| False | `False` |  |  |\r\n| Not | `Not` | ¬ | `\\n` `\\not` `\\neg` `\\lnot` |\r\n| And | `/\\` | ∧ | `\\and` `\\an` `\\wedge` |\r\n| Or | `\\/` | ∨ | `\\v` `\\or` `\\vee` |\r\n| Implies | `->` | → | `\\r` `\\imp` `\\->` `\\to` `\\r-` `\\rightarrow` |\r\n| Iff | `<->` | ↔ | `\\iff` `\\lr-` `\\lr` `\\<->` `\\leftrightarrow` |\r\n| For All | `foral` | ∀ | `\\all` `\\forall` |\r\n| Exists | `exists` | ∃ | `\\ex` `\\exists` |\r\n\r\n### **Anonymous Function**\r\nExample:\r\nAn anonymous function that swaps a conjunction\r\n```\r\n-- Ascii\r\nfun h : P ∧ Q => and_intro (and_right h) (and_left h)\r\n-- Unicode\r\nλh : P ∧ Q ↦ ⟨h.right, h.left⟩\r\n```\r\n| $Ascii~~~$ | $Unicode~~~$ | $Unicode Cmd$ |\r\n| --- | :---: | --- |\r\n| `fun` | λ | `\\fun` `\\la` `\\lambda` `\\lamda` `\\lam` `\\Gl` |\r\n| `=>` | ↦ | `\\map` `\\mapsto` |\r\n\r\n### **Other Unicode**\r\n| $Name$ | $Unicode~~~$ | $Unicode Cmd$ |\r\n| --- | :---: | --- |\r\n| Angle brackets | ⟨ ⟩ | `\\<` `\\>` `\\langle` `\\rangle` |\r\n| Subscript Numbers | ₁ ₂ ₃ ... | `\\1` `\\2` `\\3` ... |\r\n| Left Arrow | ← | `\\l` `\\leftarrow` `\\gets` `\\<-` |\r\n| Turnstyle | ⊢ | `\\│-` `\\entails` `\\vdash` `\\goal` |":
 "### **論理定数と演算子**\r\n| $名前~~~$ | $Ascii ~~~$ | $Unicode$ | $Unicode コマンド$ |\r\n| --- | :---: | :---: | --- |\r\n| 真 | `True` |  |  |\r\n| 偽 | `False` |  |  |\r\n| 否定 | `Not` | ¬ | `\\n` `\\not` `\\neg` `\\lnot` |\r\n| かつ | `/\\` | ∧ | `\\and` `\\an` `\\wedge` |\r\n| または | `\\/` | ∨ | `\\v` `\\or` `\\vee` |\r\n| 包含 | `->` | → | `\\r` `\\imp` `\\->` `\\to` `\\r-` `\\rightarrow` |\r\n| 同値 | `<->` | ↔ | `\\iff` `\\lr-` `\\lr` `\\<->` `\\leftrightarrow` |\r\n| 全称記号 | `foral` | ∀ | `\\all` `\\forall` |\r\n| 存在記号 | `exists` | ∃ | `\\ex` `\\exists` |\r\n\r\n### **匿名関数**\r\n例\r\n論理積を入れ替える匿名関数\r\n```\r\n-- Ascii\r\nfun h : P ∧ Q => and_intro (and_right h) (and_left h)\r\n-- Unicode\r\nλh : P ∧ Q ↦ ⟨h.right, h.left⟩\r\n```\r\n| $Ascii ~~~$ | $Unicode ~~~$ | $Unicode コマンド$ |\r\n| --- | :---: | --- |\r\n| `fun` | λ | `\\fun` `\\la` `\\lambda` `\\lamda` `\\lam` `\\Gl` |\r\n| `=>` | ↦ | `\\map` `\\mapsto` |\r\n\r\n### **Other Unicode**\r\n| $名前$ | $Unicode~~~$ | $Unicode コマンド$ |\r\n| --- | :---: | --- |\r\n| 角括弧 | ⟨ ⟩ | `\\<` `\\>` `\\langle` `\\rangle` |\r\n| 下付き文字 | ₁ ₂ ₃ ... | `\\1` `\\2` `\\3` ... |\r\n| 左矢印 | ← | `\\l` `\\leftarrow` `\\gets` `\\<-` |\r\n| ターンスタイル | ⊢ | `\\│-` `\\entails` `\\vdash` `\\goal` |",
 "## Summary\r\n`repeat t` repeatedly applies the tactic `t` to the goal. You don't need to use this tactic, it just speeds things up sometimes.":
 "## 概要\r\n`repeat t`は、ゴールに対しタクティク`t`を繰り返し適用します。これを使う必要はありませんが、時々、単に作業を速くします。",
 "## Summary\r\n`have` is used to add new assumptions to your proof state.\r\n\r\n`have h : P := e` adds the assumption `h : P` to the current proof state if `e` is an expression that evaluates to evidence for `P`.\r\n\r\nIf `P` is omitted, the game will attempt to infer the proposition. Most tutorial worlds will introduce alternative expressions as a shorthand where you can omit parts of the expression if the proposition being introduced can be inferred.\r\n\r\n`and_intro e₁ e₂`, and `iff_intro e₁ e₂` can both be written as `⟨e₁, e₂⟩` as long as the context makes the proposition being constructed clear. This will often mean using the long hand or including the `P` when using the `have` tactic.\r\n```\r\n-- Should h be inferred as P ∧ Q or P ↔ Q?\r\n-- To be unambiguous\r\nexact h := ⟨e₁, e₂⟩\r\n-- must become\r\nexact h : P ∧ Q := ⟨e₁, e₂⟩\r\n-- or perhaps\r\nexact h := (⟨e₁, e₂⟩ : P ∧ Q)\r\n```\r\n\r\n### Example\r\n```\r\nObjects:\r\nP Q: Prop\r\nAssumptions:\r\nh : (P → Q) ∧ ¬Q\r\nGoal:\r\n¬P\r\n```\r\n---\r\n```\r\nhave hpq := h.left\r\n```\r\ncreates the new proof state where hpq is an assumption\r\n```\r\nObjects:\r\nP Q: Prop\r\nAssumptions:\r\nh : (P → Q) ∧ ¬Q\r\nhpq : P → Q\r\nGoal:\r\n¬P\r\n```":
 "## 要約\r\n`have`は新しい仮定を証明状態に加えるために使われる。\r\n\r\n`have h : P := e`は仮定`h : P`を`e` が `P`の証拠と評価される式である場合に現在の証明状態に加える。\r\n\r\n`P`が省略された場合、ゲームはその命題を推測しようとする。ほとんどのチュートリアルワールドでは、紹介されている命題が推測できる場合、式の一部を省略できる省略表現として代替表現を紹介している。\r\n\r\n`and_intro e₁ e₂`や`iff_intro e₁ e₂`は、文脈から構成される命題が明らかである限り、どちらも`⟨e₁, e₂⟩`と書くことができる。これは多くの場合、`have`タクティクを使うときに`P`を入れたりロングハンドを使ったりすることを意味する。\r\n```\r\n-- hはP∧Qと推論すべきか、P↔Qと推論すべきか？\r\n-- 明確であること\r\nexact h := ⟨e₁, e₂⟩\r\n-- こうなるべき↓\r\nexact h : P ∧ Q := ⟨e₁, e₂⟩\r\n-- あるいは\r\nexact h := (⟨e₁, e₂⟩ : P ∧ Q)\r\n```\r\n\r\n### 例\r\n```\r\nオブジェクト:\r\nP Q: Prop\r\n仮定:\r\nh : (P → Q) ∧ ¬Q\r\nゴール:\r\n¬P\r\n```\r\n---\r\n```\r\nhave hpq := h.left\r\n```\r\nhpqを仮定とする新しい証明状態を作る。\r\n```\r\nオブジェクト:\r\nP Q: Prop\r\n仮定:\r\nh : (P → Q) ∧ ¬Q\r\nhpq : P → Q\r\nゴール:\r\n¬P\r\n```",
 "## Summary\r\n\r\nIf `h₁` is a proof of an equivalence `P ↔ Q`, then `rw [h₁]` will change\r\nall `P`s in the goal to `Q`s. It's the way to “substitute in”.\r\n\r\n## Variants\r\n\r\n* `rw [← h₁]` — changes `Q`s to `P`s; get the back arrow by typing `\\left ` or `\\l`.\r\n\r\n* `rw [h₁, h₂, h₃, h₄]` — a sequence of rewrites\r\n\r\n* `rw [h₁] at h₂` — changes `P`s to `Q`s in hypothesis `h₂`\r\n\r\n* `rw [h₁] at h₂ h₃ ⊢` — changes `X`s to `Y`s in two hypotheses and the goal;\r\nget the `⊢` symbol with `\\|-`.\r\n\r\n* `repeat rw [h₁]` — keep attempting to `rw` until there are no more matches. For example, if the goal is `¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬P` you can use `rw [not_not_not]` 9 times or just use `repeat rw [not_not_not]` once to get `¬P`\r\n\r\n* `nth_rewrite 2 [h₁]` — will change only the second `P` in the goal to `Q`.":
 "",
 "## Summary\r\n\r\nIf `h : X = Y` and there are several `X`s in the goal, then\r\n`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\r\n\r\n## Example\r\n\r\nIf the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\r\nwill change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\r\nwill change the goal to `succ 1 + succ 1 = 4`.":
 "",
 "# ∨ is commutative\r\n\r\n`or_comm` is evidence that `P ∨ Q ↔ Q ∨ P`": "# ∨は可換\r\n\r\n`or_comm`は`P ∨ Q ↔ Q ∨ P`の証拠である。",
 "# ∨ is Associative\r\n\r\n`or_assoc` is evidence that `P ∨ Q ∨ R ↔ (P ∨ Q) ∨ R`":
 "",
 "# ∧ is commutative\r\n\r\n`and_comm` is evidence that `P ∧ Q ↔ Q ∧ P`": "# ∧は可換\r\n\r\n`and_comm`は`P ∧ Q ↔ Q ∧ P`の証拠である。",
 "# ∧ is Associative\r\n\r\n`and_assoc` is evidence that `(P ∨ Q) ∨ R ↔ P ∨ Q ∨ R`":
 "",
 "# ∧ Elimination Right\r\n### `and_right : P ∧ Q -> Q`\r\n\r\nIf `h` is a term with a type like `P ∧ Q`\r\n\r\n`and_right h`, `h.right` or `h.2` are all expressions for denoting the right-hand side of the given evidence. In this case, the left side has a type of `Q`.":
 "# ∧除去則・右\r\n### `and_right : P ∧ Q -> Q`\r\n\r\nもし`h`が`P ∧ Q`のような型を持つ項なら、\r\n\r\n`and_right h`、`h.right`、`h.2`はすべて、与えられた証拠の右辺を表す表現である。この場合は、右辺の型は`Q`だ。",
 "# ∧ Elimination Left\r\n### `and_left : P ∧ Q -> P`\r\n\r\nIf `h` is a term with a type like `P ∧ Q`\r\n\r\n`and_left h`, `h.left` or `h.1` are all expressions for denoting the left-hand side of the given evidence. In this case, the left side has a type of `P`.":
 "# ∧除去則・左\r\n### `and_left : P ∧ Q -> P`\r\n\r\nもし`h`が`P ∧ Q`のような型を持つ項なら、\r\n\r\n`and_left h`、`h.left`、`h.1`はすべて、与えられた証拠の左辺を表す表現である。この場合は、左辺の型は`P`だ。",
 "# → is transitive\r\n`P → Q` and `Q → R` implies `P → R`\r\n```\r\nimp_trans : (P → Q) → (Q → R) → P → R\r\n```\r\n\r\nOf course, because of `and_comm`, you know you can flip this around too.\r\n`Q → R` and `P → Q` implies `P → R` has a near-identical proof.\r\n\r\n### Infix Operator:\r\n`imp_trans` has an infix operator. This looks like `≫` (which is written as “`\\gg`”).\r\n\r\nFor the math-inclined, because the expression for an implication is a function, you can also use function composition for the same purpose (`∘` is written as “`\\o`”). Just remember that `∘` has the parameters swapped from the way `imp_trans` is defined.":
 "# → は 推移的\r\n`P → Q`と`Q → R`から`P → R`が示される\r\n```\r\nimp_trans : (P → Q) → (Q → R) → P → R\r\n```\r\n\r\nもちろん、`and_comm`のおかげで、これを反転させることができる。\r\n「`Q → R`と`P → Q`から`P → R`が導かれる」にはほぼ同じ証明がある。\r\n\r\n### 接中辞演算子:\r\n`imp_trans`には接中辞演算子がある。それは`≫`(“`\\gg`”と書ける)のように見える。\r\n\r\n数学に精通している方へ：含意の式は関数であるため、同じ目的のために関数合成を使うこともできます(`∘`は “`\\o`”と書ける)。`∘` は、`imp_trans` の定義と比べて引数が入れ替わっている点に注意しよう。",
 "# exfalso\r\n`exfalso` is **Contradiction**'s younger brother. Using `exfalso` turns your goal to `False`. This is the same thing as using `apply false_elim`. Using the principle that “from nonsense, follows nonsense,” if you spot a contradiction in your assumptions, you can make progress by changing your goal to `False.`\\\r\n\\\r\nRemember that because `¬P` is the same as `P → False`, you can use the `apply` tactic on evidence for `¬P`":
 "",
 "# and_intro\r\n### `and_intro : P -> Q -> P ∧ Q`\r\n`and_intro` is a function with two parameters. It takes two disparate pieces of evidence and combines them into a single piece of evidence. If `(e₁ : P)` and `(e₂ : Q)` are evidence, then\r\n```\r\nhave h : P ∧ Q := and_intro e₁ e₂\r\n```":
 "# and_intro\r\n### `and_intro : P -> Q -> P ∧ Q`\r\n`and_intro`は二つのパラメーターを持つ関数だ。2つの異なる証拠を組み合わせ、1つの証拠とする。もし`(e₁ : P)`と`(e₂ : Q)`が証拠なら、\r\n```\r\nhave h : P ∧ Q := and_intro e₁ e₂\r\n```\r\nとできる。",
 "# `∧`\r\nThe hat symbol “ ∧ ” is how logicians denote a conjunction — a logical “and”. `A ∧ B` means “A and B”. It works the way you would intuitively expect. Like a lot of math operators (`+,-,÷,×`,and others), the `∧` symbol is an infix operator. This means it has a left side and a right side. Looking at `A ∧ B`, you can see that `A` is on the left and `B` is on the right.\r\n\r\n# Sending Invitations in a Single Package\r\nYou have two letters, one extending an invitation to Pippin and the other to Sybeth. Since they share a residence, you'd like to consolidate their invites into a single package for shipping. The box you're using has space for two items, one on the left and one on the right.\\\r\n\\\r\nYou've labelled the box explicitly, specifying that Pippin's invitation is on the left and Sybeth's invitation is on the right. This ensures there's no confusion about the contents of the box. Upon opening it, they will easily locate their respective invites without the need to search the entire package.\r\n# Proposition Key:\r\n- P — “**P**ippin is invited to the party”\r\n- S — “**S**ybeth is invited to the party”\r\n\r\nLike the box described in the intro, any evidence for a conjunction like `A ∧ B` will have a left part and a right part.\r\n# Assumptions\r\n- `p : P` — Your invitation for Pippin is evidence that Pippin is invited to the party\r\n- `s : S` — Your invitation for Sybeth is evidence that Sybeth is invited to the party\r\n# Goal\r\nUse `p` and `s` to produce evidence that `P ∧ S`. Remember that you use evidence (generally lowercase letters), to deduce new propositions (generally uppercase letters)\r\n\r\n# Using the `∧` Construtor\r\nThis level has unlocked “`∧`” under definitions. This has made the `and_intro` theorem available. You can use `and_intro` by giving it the two relevant pieces of evidence. The expression looks like: `and_intro e₁ e₂` where `e₁` and `e₂` are evidence.\\\r\n\\\r\nThe help page has even more detail about creating conjunctions like this (There's a common shorthand using angle-brackets `⟨` `,` `⟩` ).\r\n\r\n# A reminder\r\nUse the `exact` tactic to exhibit evidence for a goal":
 "# `∧`\r\n帽子のシンボル “ ∧ ” は 論理学者にとって接続詞-論理的な「かつ」-を表す方法です。`A ∧ B`は「AかつB」という意味です。あなたが直感的に予想されるように機能します。 いくつもの数学演算子 (`+,-,÷,×`,など)のように,記号'∧'は接中辞演算子です。つまり、左側と右側があるということです。`A ∧ B`を見ると、`A`が左で`B`が右であることがわかるでしょう。\r\n\r\n# 招待状の一括送信\r\nあなたは2つの手紙を持っていて、一枚はPippinに、もう一枚はSybethに送られます。2人は住居を共有しているので、招待状を1つのパッケージにまとめて送りたいです。あなたが使っている箱には、2つのものを入れるスペースがあり、一つは左側に、もう一つは右側にあります。\r\n\r\nあなたは箱にはっきりとラベルを貼り、ピピンの招待状は左、シベスの招待状は右と明記します。これで、箱の中身で混乱が起きないことが確実になります。開封すれば、パッケージ全体を探さなくても、それぞれの招待状を簡単に見つけることができるでしょう。\r\n# 命題キー:\r\n- P — “**P**ippin がパーティーに招待された”\r\n- S — “**S**ybethがパーティーに招待された”\r\n\r\n導入で説明した箱のように、`A ∧ B`のような接続詞に対する証拠には、左の部分と右の部分があります。\r\n# 仮定\r\n- `p : P` — Pippinのへ招待状は、Pippinがパーティーに招待されている証拠です\r\n- `s : S` — Sybethのへ招待状は、Sybethがパーティーに招待されている証拠です\r\n# ゴール\r\n`p` と `s` を使い、`P ∧ S` という証拠を作ってください。 証拠（通常は小文字）を使って、新しい命題（通常は大文字）を推論することを忘れてないでください。\r\n\r\n# `∧`コンストラクタを使う\r\nこのレベルでは、「∧」が定義の元で解禁されています。これにより、定理`and_intro`が使えるようになりました。`and_intro`を使うには、関連する2つの証拠を与える必要があります。式は次のようになります：`and_intro e₁ e₂` ここで、`e₁`と`e₂`は証拠です。\r\n\r\nヘルプページには、このような接続詞の作り方についてさらに詳しく書かれています（角括弧 `⟨`,`⟩` を使った一般的な省略形があります）。\r\n\r\n# リマインダー\r\n`exact`タクティクを使い、ゴールの証拠を示しましょう。",
 "# `right` tactic\r\nCan you guess how it works?": "# タクティク`right`\r\nどう動くかわかるかな?",
 "# `left` tactic\r\nIf your goal is a disjunction, `left` will change your goal to the left of that disjunction, ignoring the right.":
 "# タクティク`left`\r\nもしゴールが論理和なら、`left`はゴールを論理和の左側に変え、右側は無視する。",
 "# `fun _ => _`\r\nYou can create evidence for an implication by defining the appropriate function.\r\n- `have h₁ : P → P := fun p : P => p`\r\n- `have h₂ : P ∧ Q → P := fun h : P ∧ Q => h.left`\r\n\r\nGenerally, you don't need to repeat the types when they're obvious from the context.\r\n- `have h₁ : P → P := fun p => p`\r\n- `have h₂ : P ∧ Q → P := fun h => h.left`\r\n\r\n# Unicode:\r\n- `fun` can be written as `λ`\r\n- `=>` can be written as `↦`\r\n----\r\n- `have h₁ : P → P := λp ↦ p`\r\n- `have h₂ : P ∧ Q → P := λh ↦ h.left`":
 "# `fun _ => _`\r\n適切な関数を定義することで、含意の証拠を作成することができる。\r\n- `have h₁ : P → P := fun p : P => p`\r\n- `have h₂ : P ∧ Q → P := fun h : P ∧ Q => h.left`\r\n\r\n一般的に、文脈から明らかな型を繰り返す必要はない。\r\n- `have h₁ : P → P := fun p => p`\r\n- `have h₂ : P ∧ Q → P := fun h => h.left`\r\n\r\n# Unicode:\r\n- `fun`は`λ`として書ける。\r\n- `=>`は`↦`として書ける。\r\n----\r\n- `have h₁ : P → P := λp ↦ p`\r\n- `have h₂ : P ∧ Q → P := λh ↦ h.left`",
 "# `cases` for a Conjunction\r\nHere, we introduce the `cases` tactic in an unstructured context. `cases` takes a name from the local context and either splits it into multiple goals, or deconstructs it into its parts depending on the Proposition.\\\r\n\\\r\nIn this level, `cases h` will replace `h` with its `left` and `right` parts. Try it out.":
 "# 論理積への`cases`\r\nここでは、構造化されていない文脈での`cases`タクティクを紹介する。 `cases`はローカルコンテキストから名前を受け取り、それを複数のゴールに分割するか、命題に応じて、それをパーツに分解したりする。\r\n\r\nこのレベルでは、`cases h`は`h`を`left`の部分と`right` の部分で置き換える。やってみよう。",
 "# `assumption`\r\nIf the evidence you want is in your list of **Assumptions**, the `assumption` tactic will finish the level for you.":
 "# `assumption`\r\nもしあなたが欲しい証拠があなたの**仮定**のリストにあるなら、タクティク`assumption`はレベルを終わらせるだろう。",
 "# World's End\r\nThe home stretch, you can do it!\r\n\r\n# More tactic combinations\r\nYou can combine two tactics into a single tactic using `{tac1; tac2}`. This may be helpful when combined with a tactic like `repeat`. As an example, there may come a time in this level where the following can save you a bit of typing:\r\n```\r\nrepeat {intro; assumption}\r\n```":
 "# 世界の果て\r\n最終段階だ、きっとできる！\r\n\r\n# 更なるタクティクの組み合わせ\r\n2つのタクティクを`{tac1; tac2}`を使って組み合わせ、1つのタクティクにすることができる。これは、`repeat` などのタクティクと組み合わせると役立つかもしれない。例えば、このレベルでは、以下の方法でタイピングの手間を少し省ける事がある：\r\n```\r\nrepeat {intro; assumption}\r\n```",
 "# Using Tactics\r\nThe tactics available to you should provide a hint for what to do. You'll be using a tactic in a context you haven't tried before, but the result should make sense once you try it and see what happens.":
 "",
 "# Using Tactics\r\nLast level you learned that `constructor` works for biconditionals in the the same way it works for conjunction. This level demonstrates that `cases` works the way you may expect as well.":
 "",
 "# Using Only What Is Needed\r\nSybeth has left a voicemail on your answering machine. In it she says “Hello, it's Sybeth, I'm calling to confirm that Pippin is coming to the party and I am also coming to the party! See you then!”\\\r\n\\\r\nYou'd like to convince Cyna to join the party. You know that Cyna is good friends with Pippin. Constructing evidence that Pippin is attending the party might just be the key to convincing Cyna to join as well.\r\n# Proposition Key:\r\n- P — \"**P**ippin is coming to the party\"\r\n- S — \"**S**ybeth is coming to the party\"\r\n# Assumptions:\r\n- `vm : P ∧ S` — The voicemail (`vm`) is evidence that (`P ∧ S`) Pippin and Sybeth are coming to the party.\r\n# Convincing Cyna\r\nCyna is close with Pippin, but you don't know much about his friendship with Sybeth. You want only a relevant part of the voicemail. Fortunately, you know that any evidence with an `∧` has a left part and a right part. You can use this knowledge to pull evidence out of `vm`.\\\r\n\\\r\nThis can be done with either of these two methods:\r\n```\r\nhave p := and_left vm\r\nhave p := vm.left\r\n```\r\nOnce you've done this, you're very close to level 1 again where the Goal is directly in your assumptions.":
 "# 必要なものだけを使う\r\nSybethが留守番電話にボイスメールを残しています。その中で彼女はこう言っています：「もしもし、Sybethです。私もPippinもパーティに行きます！じゃあね！」\r\n\r\nあなたはCynaをパーティーに参加させたいと思います。CynaがPipinnと仲がいいのは知っています。Pippinがパーティに参加しているという証拠を作ることが、Cynaを説得する鍵になるかもしれません。\r\n# 命題キー:\r\n- P — \"**P**ippinがパーティーに来る\"\r\n- S — \"**S**ybethがパーティーに来る\"\r\n# 仮定:\r\n- `vm : P ∧ S` — ボイスメール(`vm`)は、(`P∧S`)PippinとSybethがパーティーに来るという証拠です。\r\n# シナを説得する\r\nCynaはPippinと親しいですが、Sybethとの関係についてはよく知りません。ボイスメールの関連する部分だけが必要です。幸いなことに、「∧」がつく証拠には左の部分と右の部分があることはご存じでしょう。この知識を使って、`vm`から証拠を引き出すことができます。\r\n\r\nこれはこの二つの方法のどちらかでできます：\r\n```\r\nhave p := and_left vm\r\nhave p := vm.left\r\n```\r\nこれができれば、ゴールがあなたの仮定に直接入ってくるレベル1にまた近づいたことになる。",
 "# Un-Curry\r\nIf you've got chips, then if you've got dip, then you've got a popular party snack.\\\r\n\\\r\nTherefore, if you've got chips and dip, then you've got a popular party snack!\r\n# Proposition Key:\r\n- `C` — You've got chips\r\n- `D` — You've got Dip\r\n- `S` — You've got a popular party snack":
 "# 非・カリー\r\nチップスがある時、ディップがあるなら、人気のパーティーおやつの完成です。\r\n\r\nしたがって、チップスとティップがあれば、人気のパーティーおやつの完成です！\r\n# 命題キー:\r\n- `C` — チップスがある\r\n- `D` — ディップがある\r\n- `S` — 人気のパーティーおやつがある",
 "# Two sides to every coin\r\nYou're flipping a coin to decide which team gets to guess first in *Salad Bowl*. Heads means blue team and tails means purple team. Even though you're on the purple team, you're secretly hoping it comes up heads.\r\n# Proposition Key:\r\n- B — Blue Team goes first\r\n- P — Purple Team goes First\r\n# Unlocked `iff_mp` and `iff_mpr`\r\nFor a biconditional like `h : P ↔ Q`,\r\n1. You can extract `P → Q` using `iff_mp h` or `h.mp`. `mp` here is short of modus ponens.\r\n2. You can extra `Q → P` using `iff_mpr h` or `h.mpr`. `mpr` here is short of modus ponens reversed.":
 "",
 "# Trouble with the cake\r\nThe baker from the bakery called, expressing confusion about your cake order. While he can bake a cake with icing and sprinkles, you've requested sprinkles and icing. You attempt to convey that every cake with sprinkles and icing is **also** at the same time a cake with icing and sprinkles. The baker doesn't believe you.\\\r\n\\\r\nIf you assume an arbitrary cake that has icing and that has sprinkles, show that you also have a cake that has sprinkles and has icing!\r\n# Proposition Key:\r\n- `I` — The cake has **I**cing\r\n- `S` — The cake has **S**prinkles":
 "# ケーキのトラブル\r\nパン屋から電話があり、ケーキの注文に困惑しているとのことでした。彼はアイシングとスプリンクルでケーキを焼くことができますが、あなたはスプリンクルとアイシングを要求しました。あなたは、スプリンクルとアイシングがかけられたケーキはすべて、アイシングとスプリンクルがかけられたケーキでもあることを伝えようとしています。パン屋はあなたを信じていません。\r\n\r\nアイシングとスプリンクルがかけられたケーキがあるとき、スプリンクルとアイシングがかけられたケーキもあることを示そう！\r\n# 命題キー:\r\n- `I` — ケーキにアイシングがかけられた\r\n- `S` — ケーキにスプリンクルがかけられた",
 "# Too Many Invites\r\nYou have invites for Alarfil, Ilyn, Orin, and Uriel who all live together. Unfortunately, boxes only have space for two items, but you've thought up a clever solution!\r\n1. You'll put Alarfil's and Ilyn's invites in a box,\r\n2. You'll put Orin's and Uriel's invites in another box.\r\n3. You'll put both boxes in a final box.\r\n### Nested Boxes!\r\nNesting boxes like this is a way to get around the “two items per box” rule. Ensure that everything is correctly labelled to guarantee each invite reaches the correct recipient.\r\n# Proposition Key:\r\n- A — **A**larfil is invited to the party\r\n- I — **I**lyn is invited to the party\r\n- O — **O**rin is invited to the party\r\n- U — **U**riel is invited to the party\r\n\r\n# The `have` Tactic\r\nYou can complete this level with your knowledge from the previous level without using this new tactic. For example, either of these would work:\r\n```\r\nexact and_intro (and_intro a i) (and_intro o u)\r\nexact ⟨⟨a,i⟩,⟨o,u⟩⟩\r\n```\r\nInstead of nesting this way, you can break the process down into steps using the `have` tactic. Enter “`have ai := and_intro a i`” to create your first box. After it's entered, it will appear under assumptions in the proof state. Now enter “`have ou := and_intro o u`” to create the second box.\\\r\n\\\r\nIf you followed this suggestion, your proof state should now have the following assumptions:\r\n```\r\nAssumptions:\r\na: A\r\ni: I\r\no: O\r\nu: U\r\nai: A ∧ I\r\nou: O ∧ U\r\n```\r\n\\\r\nFinally, now you can place these two boxes — `ai` and `ou` — into a third box and submit your answer using the `exact` tactic.":
 "# 多すぎる招待\r\nあなたはみんな一緒に住んでいるAlarfil、Ilyn、Orin、Urielへの招待状を持っています。残念なことに、箱には2つしか物を入れるスペースがないが、あなたは賢い解決策を思いつきました！\r\n1. AlarfilとIlynの招待状を箱に入れる。\r\n2. OrinとUrielの招待状を別の箱に入れる。\r\n3. 両方の箱を最後の箱に入れる。\r\n### 入れ子の箱！\r\nこのように箱を入れ子にすることで、「1つの箱に2つの物」というルールを回避できます。招待状が正しい人に届くよう、すべてのラベルが正しく貼られていることを確認しましょう。\r\n# 命題キー：\r\n- A — **A**larfilがパーティーに招待された\r\n- I — **I**lynがパーティーに招待された\r\n- O — **O**rinがパーティーに招待された\r\n- U — **U**rielがパーティーに招待された\r\n\r\n# タクティク `have`\r\nこの新しいタクティクを使わなくても、前のレベルの知識でこのレベルをクリアできます。 例えば、これらはどちらもうまく行くでしょう：\r\n```\r\nexact and_intro (and_intro a i) (and_intro o u)\r\nexact ⟨⟨a,i⟩,⟨o,u⟩⟩\r\n```\r\nこのように入れ子にする代わりに、`have`タクティクを使ってプロセスをステップに分解することができます。 「`have ai := and_intro a i`」と入力し、最初の箱を作ります。その後、それ証明状態での仮定の下に現れるでしょう。 ここで「`have ou := and_intro o u`」と入力し、二番目の箱を作りましょう。\r\n\r\nあなたがこの提案に従ったなら、あなたの証明状態にはこんな仮定があるはずです：\r\n```\r\n仮定:\r\na: A\r\ni: I\r\no: O\r\nu: U\r\nai: A ∧ I\r\nou: O ∧ U\r\n```\r\n\r\n最後に、2つの箱`ai` `ou`を3つ目の箱に入れて、タクティクを使って答えを提出することができます。",
 "# The ∨ Tutorial World!\r\nThis world introduces disjunction. In sentences, the connective “or” is commonly employed, while in logical formulas, the symbol “`∨`” takes the stage. By now, you’re likely developing an understanding of the dynamics of the relationship between evidence and propositions.\r\n1. Evidence for a conjunction `P ∧ Q` involves presenting a pair or tuple of evidence — one for `P` and another for `Q`.\r\n2. Evidence for an implication like `P → Q` is a function from evidence of `P` to evidence of `Q`.\r\n3. Evidence for a negation like `¬P` is a function from evidence of `P` to evidence of `False`.\r\n### 4. Evidence for a disjunction\r\nEvidence for `P ∨ Q` requires only evidence for either `P` or for `Q`. While simple at heart, this can lead to difficulties. Consider some expression that uses evidence for `P` to exhibit a proposition like `P ∨ Q` — because that expression requires only evidence for `P`, it could also be used for `P ∨ R`, or `P ∨ S`.\\\r\n\\\r\nWhile the correct proposition can often be inferred, there are times when you may see an error like: “failed to infer declaration type” or “don't know how to synthesize implicit argument”. Generally, this means that the proposition you're trying to exhibit needs to be made clear from the context or needs to be supplied directly as part of the expression.\r\n```\r\nObjects:\r\nP Q : prop\r\nAssumptions:\r\np : P\r\nGoal: P ∨ Q\r\n```\r\nBecause the goal knows what is required, the following will work.\r\n```\r\nexact or_inl p\r\n```\r\nWhen using the `have` tactic you can annotate the evidence you're introducing with the `:` operator. Then the correct proposition for the expression can be inferred. For example:\r\n```\r\nhave pvq : P ∨ Q := or_inl p\r\nexact pvq\r\n```\r\nAnother option is to provide a proposition directly inside an expression. This becomes helpful in large expressions that have many parts. Even if it's often redundant, any expression can be annotated in this way\r\n1. You can use a `show ... from ...` expression\r\n```\r\nhave pvq := show P ∨ Q from or_inl p\r\nexact pvq\r\n-- Nested show statements work too...\r\nhave pvq := show P ∨ Q from or_inl (show P from p)\r\nexact pvq\r\n```\r\n2. You can use the `:` “is evidence for” operator if you bracket appropriately. `:` has a low precedence, so you’ll need to bracket the expression in most cases.\r\n```\r\nhave pvq := (or_inl p : P ∨ Q)\r\nexact pvq\r\n-- Nested `:` work as well...\r\nhave pvq := (or_inl (p : P) : P ∨ Q)\r\nexact pvq\r\n```":
 "",
 "# The `repeat` tactic combinator\r\nSometimes you'll find you need to use the same tactic a few times in a row. Any tactic can be repeated (until it fails) using the `repeat`.\\\r\n\\\r\nIn this level, it's very likely that you'll be building a conjunction from two assumptions already available in your proof state. Once you make it that far, instead of writing\r\n```\r\nconstructor\r\nassumption\r\nassumption\r\n```\r\ntry this instead\r\n```\r\nconstructor\r\nrepeat assumption\r\n```":
 "# タクティク`repeat`・コンビネータ\r\n同じタクティクを連続して数回使用しなければならない場合があるだろう。repeatを使うと、あらゆるタクティクを（失敗するまで）繰り返し実行することができる。\r\n\r\nこのレベルでは、おそらく、証明状態ですでに利用可能な2つの仮定から論理積を構築することになる。そこまで到達したら、\r\n```\r\nconstructor\r\nassumption\r\nassumption\r\n```\r\nと書く代わりに\r\n```\r\nconstructor\r\nrepeat assumption\r\n```\r\nを試してみよう。",
 "# The `intro` Tactic\r\nThe `intro` tactic lets you define a function interactively. It introduces one or more hypotheses, optionally naming them.\\\r\n\\\r\nIn this level, `intro h` does two things. First, it adds an assumption `h : P` and second, it changes your goal from `P → P` to just `P`. In this sense, `intro h` is a bit like `λh ↦ `.":
 "# タクティク`intro`\r\n`intro`タクティクを使うと、対話的に関数を定義することができる。1つまたは複数の仮定を提示し、必要に応じてそれらを名付けることができる。\r\n\r\nこのレベルでは、`intro h`は2つの事をする。まず、それは仮定`h : P`を加え、次に、それはゴールを`P → P`から`P`へ変える。この点で、`intro h`は`λh ↦ `に少し似ている。",
 "# The `apply` Tactic\r\nThis tactic can be a bit confusing as it allows you to reason backwards. In this level, `h` gives us a means to get from P to Q. We can reason backwards and say, that because you have the means to turn evidence for P into evidence for Q — it suffices to show evidence for P.\\\r\n\\\r\nIf you write `apply h`, you'll see that this changes your goal from `Q` to `P`.":
 "# タクティク`apply`\r\nこのタクティクは、逆方向に推論できるため、少し混乱を招くかもしれない。このレベルでは、`h` は、Pから Q を得るための手段を提供する。逆から考えると、Pの証拠をQの証拠に変換する手段があるからこそ — Pの証拠を示すだけで十分である。\r\n\r\n`apply h`と書けば、ゴールが`Q`から`P`に変わることが分かるだろう。",
 "# The Power of negation\r\n\"Is it possible that if this is the cake you bought, then it's gonna taste horrible?\"\\\r\n\"I'm certain that's not possible.\"\\\r\n\"Oh, so what you're saying is that you have evidence that the cake is delicious!\"\r\n# Proposition Key:\r\n- `B` — You bought this cake\r\n- `C` — The cake tastes horrible":
 "",
 "# The Final “Redux: ¬ World Tactics” level\r\n\r\n`contradiction` is available this level, you can use it to shorten your answer a little bit.":
 "",
 "# The Ambiguous Celebration Response\r\nYour somewhat bothersome cousin just called and is asking if you're throwing your annual soirée this year. You don't want to outright lie, so you say \"I'm not not throwing the party.\"\r\n# Proposition Key:\r\n- `P` — You're throwing a party'":
 "",
 "# The Alarfil Effect\r\nYou're delighted that Alarfil will be there.\\\r\n\\\r\nRemarkably, even in moments when Alarfil lacks humor, he manages to be amusing! His comedic charm persists, regardless of circumstances.\r\n# Proposition Key:\r\n- `A` — Alarfil is humorless":
 "",
 "# Tactics, Tactics, Tactics": "",
 "# Tactics All Day Long": "",
 "# Sybeth's Punctuality\r\nSybeth is never on time. Despite her assurances that she'll grace the party with her timely presence, past experiences have proven otherwise. It's almost become a running joke, so much so that you playfully quip, \"Yeah, if you arrive on time, then I'll eat my boots.\"\r\n# Proposition Key:\r\n- `B` — You eat your boots\r\n- `S` — Sybeth is on time\r\n# `false_elim`\r\nYou've unlocked the \"false implies anything\" function. `false_elim` will take evidence for `False` and produce evidence for **anything**.\r\n# A Tip\r\nRemember you can think of `h : ¬S` as `h : S → False`.\\\r\n\\\r\nOnce you've started with `λ(s : S) ↦ `, you'll then see that the expression `h s` evaluates to evidence for `False`. If ever you have evidence for `False`, you should always immediately consider using `false_elim` to create evidence for anything — which in this case will be `B`.\\\r\n\\\r\nThere is no proof that \"keeps going\" once you've created evidence for `False`. Some proofs have multiple parts, so you may close off one line of reasoning and move on to another, but there can be no meaningful logic in any context where evidence for `False` is present.":
 "",
 "# Summary\r\nThe `exact` tactic is a means through which you give the game your answer. Many levels can be done in multiple steps. You'll use the `exact` tactic when you're ready to create the final expression. It will be evaluated to see whether it matches the goal.\r\n\r\n`exact` will work with any expression and attempt to unify it with the current goal. The simplest such expression is just a name that — `:` — “is evidence for” the goal. More complicated expressions often make use of unlocked definitions and theorems as well as function abstraction and application.\r\n\r\n# Errors\r\nBecause most of the starting levels use only the `exact` tactic and an expression, it's common to forget to specify the tactic. Sometimes this raises the error:\r\n```\r\nunknown tactic\r\n```\r\nand other times the much more ambiguous message:\r\n```\r\nno goals left\r\nThis probably means you solved the level with warnings or Lean encountered a parsing error.\r\n```\r\nHopefully we'll have better error messages in the future ☺\r\n\r\n### Example\r\n```\r\nObjects:\r\nP : Prop\r\nAssumptions:\r\nh : P\r\nGoal:\r\nP\r\n```\r\n----\r\n```\r\nexact h\r\n```\r\n\r\n### Example\r\n```\r\nObjects:\r\nP Q: Prop\r\nAssumptions:\r\nh : (P → Q) ∧ ¬Q\r\nGoal:\r\n¬P\r\n```\r\n----\r\n```\r\nexact λp ↦ and_right h (and_left h p)\r\n```":
 "# 要約\r\nタクティク`exact`は、あなたがゲームに答えを与える手段である。多くのレベルは複数のステップでできる。最終的な式を作る準備ができたら、タクティク`exact`を使うことになる。それがゴールにふさわしいかどうかが評価されるだろう。\r\n\r\n`exact`はどのような式でも動作し、現在のゴールとまとめようとする。このような表現の内最も単純な`:`は、ゴールの 「証拠となる」単なる名前である。より複雑な表現では、関数の抽象化や適用だけでなく、解禁済の定義や定理を利用することが多い。\r\n\r\n# エラー\r\nほとんどの序盤のレベルではタクティク`exact`と式しか使わないので、タクティクを指定し忘れることがよくある。これでエラーが出ることもある：\r\n```\r\nunknown tactic\r\n```\r\nまた、もっと曖昧なメッセージの時もある：\r\n```\r\nno goals left\r\nこれはおそらく、レベルを警告を伴って解いたか、Leanが解析エラーに遭遇したことを意味する。\r\n```\r\n今後、より良いエラーメッセージが出ることを期待しています☺\r\n\r\n### 例\r\n```\r\nオブジェクト:\r\nP : Prop\r\n仮定:\r\nh : P\r\nゴール:\r\nP\r\n```\r\n----\r\n```\r\nexact h\r\n```\r\n\r\n### 例\r\n```\r\nオブジェクト:\r\nP Q: Prop\r\n仮定:\r\nh : (P → Q) ∧ ¬Q\r\nゴール:\r\n¬P\r\n```\r\n----\r\n```\r\nexact λp ↦ and_right h (and_left h p)\r\n```",
 "# Sub-Proof\r\nIf your Goal is an implication, this tactic introduces one or more hypotheses, optionally naming and/or pattern-matching them.\r\n\r\nThe effect on a goal like `P → Q` is to add `P` as an assumption and change the Goal to `Q`. If the implication is already a part of a sub-proof, then once you show evidence for `Q`, the assumption `P` is discharged and can not be used for the rest of the proof.\r\n\r\nThis is is the interactive way of defining a function using tactics. You can think of discharging an assumption as the same as parameters being limited in scope to the function's body/definition.":
 "# サブ証明\r\nあなたのゴールが含意なら、このタクティクは1つ以上の仮定を提示し、必要に応じてそれらを名付けたり、パターンマッチングを行ったりする。\r\n\r\n`P → Q`のようなゴールに対する効果は、`P`を仮定に加え、ゴールに`Q`を加えることだ。その含意がサブ証明の一部である場合、`Q`の証拠を示したら、仮定`P`は破棄され、証明の残りの部分では使えない。\r\n\r\nこれは、タクティクで関数を定義するインタラクティブな方法だ。仮定を破棄することは、引数が関数の本体/定義内にスコープが制限されることと同じだと考えることができる。",
 "# So Many Cases\r\nJust keep picking the right hypothesis.": "# たくさんのケース\r\nただ、正しい仮定を選び続けるだけだ。",
 "# Snacks!\r\nWhat's a birthday party without chips and cake?\r\n# About Conditionals\r\nThis world teaches you about conditional statements. In every day sentences, you'll see such statements expressed as “if [...], then [...]” logic — “If the sky is clear at night, then we will be able to see the stars.”.\\\r\n\\\r\nThis game uses the implication arrow “ → ”. “If A, then B” is the same as “A implies B” or “`A → B`”.\\\r\n\\\r\nSo far, we've been giving our evidence and propositions real-world analogues. Doing this is a bit less desirable with conditionals as real-world evidence is often based on our understanding and not some tangible object. For example; the evidence that “If it rained, then the driveway is wet” generally doesn't come in the form of peer-reviewed physics papers. You should be thinking of the flavour text for each level as an unrefined embellishment of the symbols you're actually concerned with.\\\r\n\\\r\nThat said, at the level the flavour text works on, what would constitute evidence for a conditional statement? Well, for example; “If we have gnocchi, butter, parmesan, and black pepper, then we can cook *gnocchi cacio e pepe*”. An example of evidence for such a conditional could be a recipe with cooking instructions. You can think of the recipe as an argument explaining that the given ingredients are sufficient to be able to cook the dish.\\\r\n\\\r\nAnother example might be a safe's combination, as evidence that “I can find the hidden safe” → “I can steal the contents of the safe”. Perhaps a certification is evidence that “I won the contract” → “I will renovate the client's yard”.\\\r\n\\\r\nThe concept behind an implication, such as `A → B`, is that there exists an explicit path starting from the truth of `A`, from which you can demonstrate the truth of `B`. \\\r\n\\\r\nWhere this game abstracted the idea of `A ∧ B` into a tuple holding evidence for `A` and evidence for `B`. The way we store evidence like `A → B` is with a function that takes evidence for `A` and produces evidence for `B`.\\\r\n\\\r\n`h : A → B` reads `h` is evidence for `A → B`. While real-world analogues can be anything, the formalization used in this game will always be a function.":
 "# おやつ！\r\nポテチやケーキがない誕生日パーティーなんてありえません。\r\n# 条件について\r\nこのワールドは条件付き命題について教えてくれます。日常的な文章では、「もし［...］なら［...］」というロジックとして表現されます。 — 「もし夜空が晴れているなら、星が見える。」\r\n\r\nこのゲームでは 含意の矢“ → ”を使います。 「もしAならB」は「AはBを含意する」または「`A→B`」と同じです。\r\n\r\nこれまでのところ、私たちは証拠と命題に現実世界の類似性を与えてきました。現実世界の証拠は、目に見えるものではなく、私たちの理解に基づいていることが多いためです。例えば：「もし雨が降ったなら、車道は濡れている」という証拠は一般的に、査読を受けた物理学の論文という形では出てきません。各レベルのフレーバーテキストは、あなたが実際に関心を持っている記号の洗練されていない装飾として考えるべきです。\r\n\r\nとはいえ、フレーバーテキストが働いているレベルでは、何が条件付き命題の証拠になるのでしょうか？ 例えば：「ニョッキ、バター、パルメザンチーズ、黒コショウがあれば、*カチョエペペ*を作れる」。 このような条件に対する証拠の例として、調理法が書かれたレシピが挙げられます。レシピは、与えられた材料がその料理を作るのに充分であることを説明する根拠と考えられます。\r\n\r\n他の例としては、金庫の暗証番号が「私は隠し金庫を見つけられる」→「私は金庫の中身を盗める」という証拠になるかもしれません。おそらく証明書は、「契約を勝ち取った」→「顧客の庭を改修する」という証拠なのでしょう。\r\n\r\n`A → B`のような含意は、事実`A`から始め、事実`B`を証明できる明示的な経路が存在するという概念です。 \r\n\r\nこのゲームでは、「A∧B」という考えを、「A」の証拠と「B」の証拠を保持するタプルに抽象化しました。`A → B`のような証拠を保存する方法は、`A`の証拠を受け取り、`B`の証拠を生成する関数です。\r\n\r\n`h : A → B`は「`h`は`A → B`の証拠である」と読みます。実世界の類似物は何でもあり得ますが、このゲームで使われる形式化は常に関数です。",
 "# Show a Disjunction\r\nEvidence for `P ∨ Q` can be created in two ways. `left` changes the goal to `P` while `right` changes the goal to `Q`.":
 "# 論理和を示す\r\n`P ∨ Q`の証拠は2つの方法で作れる。`left`はゴールを`P`に変え、`right`はゴールを`Q`に変える。",
 "# Self Contradictory\r\nYou start this level with the `intro` tactic. This will add an assumption to your proof state and change your goal to `False`.":
 "",
 "# Self Contradictory\r\nAlarfil claims Lippa is coming and Cyna claims Lippa is not coming. They can't both be right.\r\n# Proposition Key:\r\n- `L` — **L**ippa is attending the party":
 "",
 "# Rinse and Repeat\r\nWhen you were writing expressions before, level 4 needed `and_left` while level 5 needed `and_right`. Tactics can incorporate an arbitrary amount of automation. In this case, because `assumption` will do a search through your assumptions for you, your proof for this level can be 100% identical to the one you used in the last level.":
 "# 繰り返し\r\n以前、式を書いていたとき、レベル4では`and_left`が必要だったが、レベル5では`and_right`が必要だ。タクティクは任意の自動化を取り入れることができる。今回は、`assumption`があなたの代わりに仮定を検索してくれるから、このレベルの証明は、前回のレベルで使ったものと100％同じにすることができる。",
 "# Right-Hand Swap\r\nYou'll need h1.mp in order to turn evidence for Q into evidence for R":
 "",
 "# Right-Hand Swap": "",
 "# Rewrite the goal\r\n## To an extreme\r\nYou're playing a round of *The Resistance*. You've been diligently figuring out who is a member of the resistance and who is a spy. It's a bit complicated, but you've reasoned that the current state of affairs is possible if and only if Alarfil and Cyna are members of the resistance and Pippin is a spy. You also know from an earlier reveal that Pippin and Lippa must be on the same team. Therefore, the same argument applies to Lippa as well.\r\n# Proposition Key:\r\n- A — Alarfil is a member of the resistance\r\n- C — Cyna is a member of the resistance\r\n- L — Lippa is a member of the resistance\r\n- P — Pippin is a member of the resistance\r\n# The `rw` tactic\r\nDepending on the order you've chosen to do the tutorial worlds, you may not yet be familiar with all the symbols in the current proof state. In fact, you may not even have unlocked the tools in your inventory necessary to complete this level. Don't worry, the rewrite tactic makes this level a breeze.\\\r\n\\\r\nFirst, take a look at the proof state and notice that `h₂` and the Goal are extremely similar. In fact, if you replace every occurrence of `L` with `P`, then the two would be identical. That's where `rw` comes in.\r\n\\\r\nIf you have `hpq : P ↔ Q` then `rw [hpq]` will change all `P`s in the goal to `Q`s. It's the way to “substitute in”.\\\r\n\\\r\nThe `rw` tactic is an automation tool. It does the rote work of taking apart an expression, looking for a matching sub-expression, swapping in the equivalent sub-expression and then constructing the new equivalent term from there.\\\r\n\\\r\nTry it out!":
 "",
 "# Remembering Algebra\r\nIn math class, you may have learned an acronym like BEDMAS or PEMDAS to remember the precedence of operators in your math expressions:\r\n1. Brackets (or Parentheses)\r\n2. Exponents\r\n3. Division or Multiplication\r\n4. Addition or Subtraction\r\n\r\nThese rules exist for the logical operators as well.\r\n# Brackets\r\nBrackets group or disambiguate expressions. You can think of precedence rules as deciding where brackets belong. If an operator is an infix operator, then it has an associativity as well.\r\n- right-associative: `P ∧ Q ∧ R` ≡ `P ∧ (Q ∧ R)`\r\n- left-associative: `1 + 2 + 3` ≡ `(1 + 2) + 3`\r\n- non-associative: `P ↔ Q ↔ R` is an error\r\n# High to low Precedence\r\nFunction application doesn't have an operator, it's just `function <space> argument`. It has max precedence and is left associative (meaning `and_intro p q` ≡ `(and_intro p) q`).\r\n### Propositional Operators\r\n| $Operator$ | $~~~Precedence$ | |\r\n| :---: | :---: | --- |\r\n| ¬ | max | |\r\n| ∧ | 35 | right-associative |\r\n| ∨ | 30 | right-associative |\r\n| → | 25 | right-associative |\r\n| ↔ | 20 | non-associative |\r\n| ∃ | __ | |\r\n| ∀ | __ | |\r\n### Expression Operators\r\n| $Operator$ | $~~~Precedence$ | |\r\n| :---: | :---: | --- |\r\n| ≫ | 85 | left-associative |\r\n| |> | min + 1 | right-associative |\r\n| <| | min | left-associative |\r\n### Example:\r\n```\r\n¬P ∨ Q ∧ P → Q ↔ Q ∨ R ∨ ¬S\r\n-- ¬ binds the tightest:\r\n(¬P) ∨ Q ∧ P → Q ↔ Q ∨ R ∨ (¬S)\r\n-- Next is ∧\r\n(¬P) ∨ (Q ∧ P) → Q ↔ Q ∨ R ∨ (¬S)\r\n-- Next is ∨, associated right\r\n(¬P) ∨ (Q ∧ P) → Q ↔ Q ∨ (R ∨ (¬S))\r\n-- The rest of ∨\r\n((¬P) ∨ (Q ∧ P)) → Q ↔ (Q ∨ (R ∨ (¬S)))\r\n-- Next is →\r\n(((¬P) ∨ (Q ∧ P)) → Q) ↔ (Q ∨ (R ∨ (¬S)))\r\n-- No more steps as this is fully disambiguated\r\n```\r\nHere's a version where you can see it aligned\r\n```\r\n   ¬P  ∨  Q ∧ P   → Q  ↔  Q ∨  R ∨  ¬S\r\n  (¬P) ∨  Q ∧ P   → Q  ↔  Q ∨  R ∨ (¬S)\r\n  (¬P) ∨ (Q ∧ P)  → Q  ↔  Q ∨  R ∨ (¬S)\r\n  (¬P) ∨ (Q ∧ P)  → Q  ↔  Q ∨ (R ∨ (¬S))\r\n ((¬P) ∨ (Q ∧ P)) → Q  ↔ (Q ∨ (R ∨ (¬S)))\r\n(((¬P) ∨ (Q ∧ P)) → Q) ↔ (Q ∨ (R ∨ (¬S)))\r\n```":
 "",
 "# Remember to use `or_assoc` and `and_assoc`\r\nEven without the `rw` tactic, this can be solved in a few lines.":
 "",
 "# Redux: ∨ World Tactics\r\nWelcome to the redux of the **∨ Tutorial World**. Every level is the same, but instead of solving each level with `have` and `exact`, this world opens up a bunch of custom tactics.\\\r\n\\\r\nThis world introduces tactics that you can use in lieu of the expressions you've learned so far.":
 "# 再開: ∨ タクティクの世界\r\nチュートリアルの再編集版へようこそ。どのレベルも同じだが、各レベルを`have`と`exact`で解く代わりに、このワールドではカスタムタクティクの数々が開かれている。\r\n\r\nこのワールドでは、これまで学んだ式の代わりに使えるタクティクを紹介している。",
 "# Redux: ∧ World Tactics\r\nWelcome to the redux of the **∧ Tutorial World**. Every level is the same, but instead of solving each level with `have` and `exact`, this world opens up a bunch of custom tactics.\\\r\n\\\r\nThis world introduces tactics that you can use in lieu of the expressions you've learned so far.":
 "# 再開：∧ タクティクの世界\r\nチュートリアルの再編集版へようこそ。どのレベルも同じだが、各レベルを`have`と`exact`で解く代わりに、このワールドではカスタムタクティクの数々が開かれている。\r\n\r\nこのワールドでは、これまで学んだ式の代わりに使えるタクティクを紹介している。",
 "# Redux: ↔ World Tactics\r\nWelcome to the redux of the **↔ Tutorial World**. Every level is the same, but instead of solving each level with `have` and `exact`, this world opens up a bunch of custom tactics.\\\r\n\\\r\nThis world introduces tactics that you can use in lieu of the expressions you've learned so far.":
 "",
 "# Redux: → World Tactics\r\nWelcome to the redux of the **→ Tutorial World**. Every level is the same, but instead of solving each level with `have` and `exact`, this world opens up a bunch of custom tactics.\\\r\n\\\r\nThis world introduces tactics that you can use in lieu of the expressions you've learned so far.":
 "# 再開：→ タクティクの世界\r\nチュートリアルの再編集版へようこそ。どのレベルも同じだが、各レベルを`have`と`exact`で解く代わりに、このワールドではカスタムタクティクの数々が開かれている。\r\n\r\nこのワールドでは、これまで学んだ式の代わりに使えるタクティクを紹介している。",
 "# Redux: ¬ World Tactics\r\nWelcome to the redux of the **¬ Tutorial World**. Every level is the same, but instead of solving each level with `have` and `exact`, this world opens up a bunch of custom tactics.\\\r\n\\\r\nThis world introduces tactics that you can use in lieu of the expressions you've learned so far.":
 "",
 "# Propositional Identity\r\nThis is the \\\"I think therefore I am\\\" of propositional logic. Like `True` it is a simple tautology whose truth requires no premises or assumptions — only reason alone.\r\n```\r\nidentity : P → P\r\n```":
 "# 恒等性の命題\r\nこれは命題論理の「我思う、ゆえに我あり」である。`True`と同様、単純なトートロジーであり、その真実には前提も仮定も必要ない。ただ理性のみが必要だ。\r\n```\r\nidentity : P → P\r\n```",
 "# Propositional Equivalence\r\n`P ↔ Q` means that `P` and `Q` must have the same truth value. This is often said as “`P` if and only iff `Q`” or “`P` is logically equivalent to `Q`”.\r\n\r\n`iff_intro` is the way to prove a biconditional like `P ↔ Q`. It requires you to show evidence for both `P → Q` and `Q → P`.":
 "",
 "# Proof State\r\nThe proof state in the level is as short as you've seen so far. There are no **Objects** or **Assumptions** listed.\\\r\n\\\r\nIn other levels, you get a proposition key and in the proof state — under **Objects** — you'd see something like `P Q : Prop`. When you see `P` in a level, it's a variable standing in for whatever proposition is in the proposition key. The game freely re-uses these letters in other levels as they can stand in for anything.\\\r\n\\\r\nYou won't see `False` listed under objects, just as you won't see **Theorems** or **Definitions** listed under assumptions. This just means that `False` never changes from level to level. It's never a stand-in for anything else. It's a fully defined and always available proposition.\r\n## Not False\r\nInuitively, it should be very simple to provide evidence for \"not false\". Since `¬P` is shorthand for `P → False`, you should think of `¬False` as shorthand for `False → False`. To drive home the fact that `False` is a proposition, this has the same proof as `P → P` (Which you solved in \"**→ Tutorial, level 2**\").":
 "",
 "# Practise Makes Perfect\r\nYou only have `assumption` and `constructor` available to you. Figure out the order you need to enter them in.":
 "# 習うより慣れろ\r\nあなたが使えるのは`assumption`と`constructor`だけだ。それらを入力する順番を理解しよう。",
 "# Pattern matching tip\r\nYou can solve this level using the knowledge you've aquired so far. If you've used a language with destructuring or pattern matching before, then you can introduce and pattern-match in one step with `intro ⟨nq, p⟩`. Doing so means you won't need the `cases` tactic for this level.":
 "",
 "# Party Games\r\nHere's the deal. Ilyn and Cyna both said they're bringing board games and you're sure at least one of them is going to make it. So there's definitely board games at the party!\r\n# Proposition Key:\r\n- `B` — There will be boardgames at the party\r\n- `C` — Cyna is coming to the party\r\n- `I` — Ilyn is coming to the party\r\n# Or Elimination\r\nIf you can conclude something from `A` and you can conclude the same thing from `B`, then if you know `A ∨ B` it won't matter which of the two happens as you can still guarantee something.\r\n# You've unlocked `or_elim`\r\n`or_elim` has three parameters:\r\n1. takes evidence for a disjunction,\r\n2. evidence an implication on the left,\r\n3. evidence for an implication on the right.\r\n\r\n`or_elim` is your first 3-parameter function. The associated proposition is `or_elim : (P ∨ Q) → (P → R) → (Q → R) → R`.\r\n```\r\npvq: P ∨ Q\r\npr : P → R\r\nqr : Q → R\r\nhave r : R := or_elim pvq pr qr\r\n```":
 "# パーティーゲーム\r\nこうしよう。 IlynもCynaもボードゲームを持ってくると言っていて、あなたはどちらか一人が必ず来ると信じています。じゃあパーティーには確かにボードゲームがあるよ！\r\n# 命題キー:\r\n- `B` — パーティーにはボードゲームがある\r\n- `C` — Cynaはパーティーに来る\r\n- `I` — Ilynはパーティーに来る\r\n# 「または」の除去\r\nもし`A`から何かを結論付けられ、`B`からも同じことを導け、そして`A ∨ B`を知っているなら、そのどちらが起きるかにかかわらず同じことを導けます。\r\n# `or_elim`を解禁した\r\n`or_elim`は3つの引数があります:\r\n1. 排他的論理和の証拠を取り、\r\n2. 左側の含意の証拠を取り、\r\n3. 右側の含意の証拠を取ります。\r\n\r\n`or_elim`はあなたの初めての3引数関数です。関連付けられた命題は`or_elim : (P ∨ Q) → (P → R) → (Q → R) → R`.\r\n```\r\npvq: P ∨ Q\r\npr : P → R\r\nqr : Q → R\r\nhave r : R := or_elim pvq pr qr\r\n```",
 "# Party Games\r\nA soirée requires a diligent and clear-headed host if the guests are to have fun. It's your job to ensure everybody is having a good time. Let the games begin!\r\n\r\n# Propositional Equivalence\r\n## Biconditional: If and only if\r\nThe `↔` operator doesn't introduce anything new. `P ↔ Q` can be constructed whenever evidence for both `P → Q` and `Q → P` is available. In general, if `h₁` and `h₂` are evidence as follows:\r\n```\r\nh₁ : P ↔ Q\r\nh₂ : (P → Q) ∧ (Q → P)\r\n```\r\nThen `h₁` and `h₂` have roughly the same capabilities. Also, proof of either P or Q or ¬P or ¬Q, immediately translates to the same proof for the logically equivalent proposition. The following levels will explain the details.\\\r\n\\\r\nThe main new idea introduced in this tutorial world is the `rw` tactic. The *rewrite* tactic offers a principled way to alter the current goal or available hypotheses of your current proof state.":
 "",
 "# Or Introduction Right\r\nYou know that skittles are super colourful. Which means that either sprinkles are super colourful or skittles are super colourful.\r\n# Proposition Key:\r\n- `K` — sprinkles are super colourful\r\n- `S` — skittles are super colourful\r\n# New unlock\r\nYou've just unlocked `or_inr`. It turns evidence for the righthand of an `∨` proposition into a disjunction.":
 "# 「または」の導入則・右\r\nあなたは、スキットルズがすごくカラフルであることを知っています。つまり、スプリンクルがすごくカラフルであるか、スキットルズがすごくカラフルであるということです。\r\n# 命題キー:\r\n- `K` — スプリンクルはすごくカラフルである\r\n- `S` — スキットルズはすごくカラフルである\r\n# 新機能の解禁\r\n`or_inr`を解禁しました。それは、`∨`命題の右辺の証拠を、論理和に変換します。",
 "# Or Introduction Right\r\nTurns evidence for the righthand of an `∨` proposition into a disjunction. The context must supply what the lefthand side of the disjunction is.\r\n```\r\n-- Objects\r\nP Q : Prop\r\n-- Assumptions\r\nq : Q\r\n```\r\nallows:\r\n```\r\nhave h : P ∨ Q := or_inr q\r\nhave h := (or_inl q : P ∨ Q)\r\nhave h := show P ∨ Q from or_inl q\r\n```\r\n\"":
 "# 「または」の導入則・右\r\n`∨`命題の右辺の証拠を、論理和に変換する。文脈は、論理和の左辺が何を指すか明確にしなければならない。\r\n```\r\n-- オブジェクト\r\nP Q : Prop\r\n-- 仮定\r\nq : Q\r\n```\r\n許可される:\r\n```\r\nhave h : P ∨ Q := or_inr q\r\nhave h := (or_inr q : P ∨ Q)\r\nhave h := show P ∨ Q from or_inr q\r\n",
 "# Or Introduction Left\r\nYou know that skittles are super colourful. Which means that either skittles are super colourful or oranges are a vegetable.\r\n# Proposition Key:\r\n- `O` — Oranges are a vegetable\r\n- `S` — skittles are super colourful\r\n# New unlock\r\nYou've just unlocked `or_inl`. It turns evidence for the lefthand of an `∨` proposition into a disjunction.":
 "# 「または」の導入則・左\r\nあなたは、スキットルズがすごくカラフルであることを知っています。つまり、スキットルズがすごくカラフルであるか、オレンジは野菜であるということです。\r\n# 命題キー:\r\n- `O` — オレンジは野菜である\r\n- `S` — スキットルズはすごくカラフルである\r\n# 新機能の解禁\r\n`or_inl`を解禁しました。それは、`∨`命題の左辺の証拠を、論理和に変換します。",
 "# Or Introduction Left\r\nTurns evidence for the lefthand of an `∨` proposition into a disjunction. The context must supply what the righthand side of the disjunction is.\r\n```\r\n-- Objects\r\nP Q : Prop\r\n-- Assumptions\r\np : P\r\n```\r\nallows:\r\n```\r\nhave h : P ∨ Q := or_inl p\r\nhave h := (or_inl p : P ∨ Q)\r\nhave h := show P ∨ Q from or_inl p\r\n```":
 "# 「または」の導入則・左\r\n`∨`命題の左辺の証拠を、論理和に変換する。文脈は、論理和の右辺が何を指すか明確にしなければならない。\r\n```\r\n-- オブジェクト\r\nP Q : Prop\r\n-- 仮定\r\np : P\r\n```\r\n許可される:\r\n```\r\nhave h : P ∨ Q := or_inl p\r\nhave h := (or_inl p : P ∨ Q)\r\nhave h := show P ∨ Q from or_inl p\r\n",
 "# Or Elimination\r\nIf you can conclude something from `A` and you can conclude the same thing from `B`, then if you know `A ∨ B` it won't matter which of the two happens as you can still guarantee something.\r\n\r\nor_elim is also evidence:\r\n```\r\nor_elim : (P ∨ Q) → (P → R) → (Q → R) → R`\r\n```\r\n# Parameters\r\n`or_elim` has three parameters:\r\n1. takes evidence for a disjunction,\r\n2. evidence an implication on the left,\r\n3. evidence for an implication on the right.\r\n# Example\r\n`or_elim` is your first 3-parameter function.\r\n```\r\npvq: P ∨ Q\r\npr : P → R\r\nqr : Q → R\r\nhave r : R := or_elim pvq pr qr\r\n```":
 "# 「または」の除去\r\nもし`A`から何かを結論付けられ、`B`からも同じことを導け、そして`A ∨ B`を知っているなら、そのどちらが起きるかにかかわらず同じことを導ける。\r\nor_elimは証拠でもある:`\r\nor_elim : (P ∨ Q) → (P → R) → (Q → R) → R`\r\n`\r\n # 引数\r\n`or_elim`は3つの引数がある:\r\n1. 排他的論理和の証拠を取り、\r\n2. 左側の含意の証拠を取り、\r\n3. 右側の含意の証拠を取る。\r\n\r\n# 例\r\n`or_elim`はあなたの初めての3引数関数だ。関連付けられた命題は`or_elim : (P ∨ Q) → (P → R) → (Q → R) → R`.\r\n```\r\npvq: P ∨ Q\r\npr : P → R\r\nqr : Q → R\r\nhave r : R := or_elim pvq pr qr\r\n```",
 "# Old Hat\r\nYou've got this.": "# おなじみの\r\n君ならできる。",
 "# Nothing New\r\nJust use what you've been taught.": "# 新しいことはない\r\n教えてもらったことを使うだけだ。",
 "# Nothing New\r\nJust use what you know. Start with `intro` to give yourself an assumption to work with":
 "# 新しいことはない\r\n知っていることを使うだけだ。`intro`で始めて、作業の基盤となる仮定を得よう。",
 "# Negation is stable\r\nA nice result of this theorem is that any more than 2 negations can be simplified down to 1 or 2 negations.\r\n```\r\nnot_not_not : ¬¬¬P ↔ ¬P\r\n```":
 "",
 "# More practise\r\nThis level will require `apply` again. Remember that it lets you reason backwards on the goal.":
 "# もっと練習\r\nこのレベルでは再び`apply`が必要になる。ゴールに対して逆方向に推論する点に注意しよう。",
 "# Modus Tollens\r\nIf Bella comes to the party, she is certain to perform a bawdy song. You've assured Sybeth that there will be no bawdy songs at the event. Sybeth is disappointed to discover that Bella won't be joining.\r\n# Proposition Key:\r\n- `B` — Bella is attending the party\r\n- `S` — A bawdy song will be sung":
 "",
 "# Modus Tollens\r\nDenying the consequent.\r\n\r\nIf P, then Q.\\\r\nNot Q.\\\r\nTherefore, not P.\r\n```\r\nmt : (P → Q) → ¬Q → ¬P\r\n```\r\n\r\n### Infix Operator:\r\n`modus_tollens` is a specialized version of `imp_trans`, which makes it possible to use `≫` (which is written as “`\\gg`”) as an infix operator for `modus_tollens`.":
 "",
 "# Modus Tollens\r\nBy now you're getting used to using `intro` and `apply` on negated propositions. Keep it up!":
 "",
 "# Mixed Up Conjunctions\r\nRecall when you placed the invites for Alarfil, Ilyn, Orin, and Uriel in separate boxes. There was a mix-up in the arrangement. Can you fix it so that Alarfil and Uriel's invites are together?\r\n# Proposition Key:\r\n- A — **A**larfil is invited to the party\r\n- I — **I**lyn is invited to the party\r\n- O — **O**rin is invited to the party\r\n- U — **U**riel is invited to the party":
 "# 混同された接続詞\r\nあなたがAlarfil、Ilyn、Orin、Urielの招待状を別々の箱に入れたときのことを思い出してください。配置に間違いがありました。Alarfil と Uriel の招待状が一緒になるように直せますか？\r\n# 命題キー：\r\n- A — **A**larfilがパーティーに招待された\r\n- I — **I**lynがパーティーに招待された\r\n- O — **O**rinがパーティーに招待された\r\n- U — **U**rielがパーティーに招待された",
 "# Let there be cake!\r\nYou've found an online bakery service. Their website details how the cake delivery service works.\\\r\n\\\r\nIf you send them evidence of payment, then you'll receive an email detailing when the cake will be delivered. The system is automated for you, so you can send it evidence of payment as often as you like and it'll always instantly return the same evidence that the cake will be delivered.\r\n# Proposition Key:\r\n- `P` — You've **P**aid for the cake\r\n- `C` — The **C**ake will be delivered\r\n# Implication \" → \"\r\nYou use an implication the same way you've been using `and_intro`, `and_left`, and `and_right`. You write out the name of the implication and then write the name of the evidence required for the left side of the \" → \" next to it. Juxtaposition just means “to place next to each other,” which is what this is style of function application is called.\r\n- assumption `a : A`\r\n- assumption `h₁ : A → B`\r\n- have `b : B := h₁ a`\r\n\r\nYou can read `h₁ a` as modus ponens. In fact, you've unlocked a theorem called modus_ponens that you could use here. Since modus ponens is implemented as function application, you can — and should — always just Juxtapose instead.\r\n# A note\r\nYou'll often see assumptions given one or two letter names (`p`, `r`, `q`, `h₁`, `h₂`, `h₃`, etc). Assumptions are generally not long-lived. They are part of some expression, exhibit some implication, and then are discarded. Their names in this context don't need to be particularly memorable.\\\r\n\\\r\nTheorems — like those on the right side of the game screen — can be thought of as assumptions that are always available for every level (and therefore do not need to be listed under assumptions for any given level). They tend to have longer names because they will be available for all future levels.\\\r\n\\\r\nName-length is not a hard and fast rule, just a common idiom. For a counter-example; this level gives the assumption `bakery_service` a longer name.\r\n\r\n# Reminder\r\nExhibit evidence for the goal using the `exact` tactic.":
"# ケーキを用意しよう！\r\nあなたはオンラインベーカリーサービスを見つけました。そのウェブサイトでは、ケーキ宅配サービスの仕組みが詳しく紹介されています。\r\n\r\n支払い証明書を送れば、ケーキがいつ届けられるかの詳細がメールで届きます。システムは自動化されているので、何度でも支払い証明書を送ることができ、ケーキが届けられるという同じ証拠を常にすぐに返してくれます。\r\n# 命題キー:\r\n- `P` — あなたはケーキの代金を支払った(**P**aid)\r\n- `C` — ケーキ(**C**ake)が届けられる\r\n# 含意 「→」\r\n`and_intro`、`and_left`、`and_right`と同じように含意を使います。含意の名前を書き、その横に「→」の左側に必要な証拠の名前を書きます。Juxtaposition（並置）とは、「隣同士に配置する」という意味であり、この形式の関数適用はそう呼ばれています。\r\n- `a : A`を仮定\r\n- `h₁ : A → B`を仮定\r\n- `b : B := h₁ a`を得る\r\n\r\n`h₁ a`はモーダスポネンスと読めます。実際、あなたはmodus_ponensという定理をアンロックしたので、ここで使えます。モーダスポネンスは関数適用として実装されているので、その代わりにJuxtaposeを使えばいい(そしてそうすべき)です。\r\n# メモ\r\n仮定に1、2文字の名前（`p`、`r`、`q`、`h₁`、`h₂`、`h₃`など）が付けられているのをよく見かけます。仮定は一般的に長命ではありません。何らかの式の一部になり、何らかの含意を示し、そして捨てられます。この文脈での彼らの名前は、特に印象に残るものである必要はありません。\r\n\r\nゲーム画面の右側にあるような定理は、すべてのレベルで常に使える仮定と考えることができます（つまり、どのレベルの仮定にもそれを書く必要はありません）。それらは将来の全レベルで使えるため、名前が長くなる傾向がある。\r\n\r\n名前の長さは厳密なルールではなく、一般的な慣例に過ぎません。実際、このレベルでは仮定に`bakery_service`という長い名前があります。\r\n\r\n# リマインダー\r\nタクティクを使ったゴールの証拠を示そう。",
 "# Let the festivities commence!\r\nYou're hosting your yearly soirée, and it's time to start planning! Last year your planning went so poorly that nobody showed up. Not for lack of trying though, they just wound up at a number of bewildering addresses. The silver lining was that all your friends were safe from the fire when, accidentally, you burned down your entire apartment building.\\\r\n\\\r\nThis year will be different‼ This year, if you want to be sure that there will be fancy cheeses, you had better have evidence that somebody is bringing the cheese platter.\r\n\r\nWorld 1: **Party Invites** is a tutorial world that is meant to introduce you to conjunction — the logical “and”. The symbol used to denote an “and” looks like “`∧`”. You'll learn to how to use evidence to create an `∧` and also how to get evidence out when it's been `∧`ed together.\\\r\n\\\r\nThe real-world analogues for evidence of `A ∧ B` might be a box with evidence for `A` and evidence for `B`, an audio recording with both pieces of evidence, or a tree with evidence in its branches.\\\r\n\\\r\nWhile real-world analogues can be anything, the abstract machinery used in this game will always be the same. In the case of the `∧` operator, the game stores the associated evidence in a tuple data structure.\\\r\n\\\r\nThe details aren't important. Each level will be encoded for you into the symbols of a proof state. The puzzle, at its core, will be about symbol manipulation. Much of the text is there for added fun and flair.\r\n\r\n# **Aside**: Expressions\r\nIf you're coming at this as a puzzle, part of the goal of the tutotial worlds is to teach you how to form expressions and to think about what they evaluate to. Consider how how these expressions all evaluate to the same number:\r\n```\r\n4 + 6\r\n(4) + 6\r\n(4) + (6)\r\n3 + 1 + 6\r\n3 + (1 + 6)\r\n4 + 4 + 2\r\n(4 * 2) + 2\r\n```\r\nand how some things which may look like expressions really are not:\r\n```\r\n4 6\r\n4 +\r\n4 (++) 6\r\n(4 +) 6\r\n```\r\nThe expressions that this game is asking you to form are mostly in prefix form. In context, this means the operation is given a textual name instead of a symbol and the parameters are separated by spaces **after** the name. For example; the above expressions may look like:\r\n```\r\nadd 4 6\r\nadd (4) 6\r\nadd (4) (6)\r\nadd (add 3 1) 6\r\nadd 3 (add 1 6)\r\nadd (add 4 4) 2\r\nadd (mul 4 2) 2\r\n```\r\nWe're not using expressions to express numbers, but many of the concepts do carry over. Instead of numbers, we're working with logical inferences.":
 "# さあ、お祭りの始まりだ！\r\n毎年恒例の晩餐会を開催することになり、そろそろ計画を立て始める時期だ！昨年は計画がうまくいかず、誰も来ませんでした。しかし、努力が足りなかったわけではありません、手紙が多くの不可解な住所に行き着いただけです。 不幸中の幸いだったのは、誤ってアパート全体を全焼させてしまったときに、友人たちが全員無事だったことです。\r\n\r\n今年は違います‼ 高級チーズが出ることを確信したいなら、誰かがチーズの盛り合わせを持ってくるという証拠があったほうがいいでしょう。\r\n\r\nWorld 1: **パーティーの招待** は接続詞 — 論理的な「かつ」 — を紹介するチュートリアルワールドです。「かつ」を表す記号は「`∧`」のように見えます。 証拠を使ってどのように「∧」を作るか、また、「∧」された証拠をどのように取り出すかを学びましょう。\r\n\r\n「A ∧ B」の証拠に似た現実世界のものとして、「A」の証拠と「B」の証拠が入った箱、両方の証拠がある録音データ、あるいは枝に証拠がある木かもしれません。\r\n\r\n現実世界の類似物は何でもあり得ますが、このゲームで使われる抽象的なメカニズムは常に同じです。演算子`∧`の場合では、ゲームは関連する証拠をタプルのデータ構造に格納します。\r\n\r\n詳細は重要ではありません。各レベルは証明状態の記号にエンコードされます。このパズルの核心は、記号の操作にあります。テキストの多くは、楽しさとセンスを加えるためにあります。\r\n\r\n# **余談**： 式\r\nもし、あなたがこれをパズルとして見ているのであれば、チュートリアルワールドのゴールのひとつは、式の立て方と、その式が何に評価されるのかを考える方法を教えることです。これらの式がすべて同じ数に評価される仕組みを考えてみよう：\r\n```\r\n4 + 6\r\n(4) + 6\r\n(4) + (6)\r\n3 + 1 + 6\r\n3 + (1 + 6)\r\n4 + 4 + 2\r\n(4 * 2) + 2\r\n```\r\nそして、一見式のように見えるものが、実はそうではないというもの：\r\n```\r\n4 6\r\n4 +\r\n4 (++) 6\r\n(4 +) 6\r\n```\r\nこのゲームがあなたに求める式は、ほとんどが接頭辞形式です。つまり、記号の代わりにテキスト名をつけ、名前の**後**にあるパラメータの間は空白で区切ります。たとえば、上の式は次のようになります：\r\n```\r\nadd 4 6\r\nadd (4) 6\r\nadd (4) (6)\r\nadd (add 3 1) 6\r\nadd 3 (add 1 6)\r\nadd (add 4 4) 2\r\nadd (mul 4 2) 2\r\n```\r\n数字を表す式は使いませんが、多くの概念は引き継がれます。数字の代わりに論理的推論を扱います。",
 "# Left-Hand Swap\r\nYou'll need `h1.mpr` in order to turn evidence for R into evidence for P":
 "",
 "# Left-Hand Swap": "",
 "# Keep rewriting!\r\nIt's another round of the resistance! This time you know that if you could prove that Alarfil, Cyna, or Lippa are part of the resistance, then that would be good enough to show that least one of the other two are spies.\\\r\n\\\r\nIt doesn't really matter how your friends are paired up, the same truth will hold.\r\n# Proposition Key:\r\n- A — Alarfil is a member of the resistance\r\n- C — Cyna is a member of the resistance\r\n- L — Lippa is a member of the resistance\r\n## New Theorems\r\nTwo new theorems have been unlocked for this level. We'll make you prove them later — though I imagine they make a certain amount of intuitive sense regardless.\r\n1. `or_assoc : P ∨ Q ∨ R ↔ (P ∨ Q) ∨ R`\r\n2. `and_assoc : P ∧ Q ∧ R ↔ (P ∧ Q) ∧ R`\r\n## A Challenge\r\nYou'll likely see the way this can be solved using the `rw` tactic. In this case, there's a nice and short proof that doesn't use `rw`. If you want the extra challenge, see if you can see it.":
 "",
 "# Keep it up": "# 頑張ってください",
 "# It suffices to show\r\nTo prove `Q` by `P → Q`, it suffices to show `P`.\r\n### More Generally\r\nTo prove `Q` by `P₁ → P₂ → P₃ → ... → Q`, it suffices to show `P₁, P₂, P₃, ...`. One way to convince yourself this is true is to prove that `(P₁ → P₂ → Q) → (P₁ ∧ P₂ → Q)` and convince yourself there exists a procedure for any `(P₁ → P₂ → ... → Q) → (P₁ ∧ P₂ ∧ ... → Q)`\r\n### In Practice\r\nThe `apply` tactic returns as many subgoals as the number of premises that have not been fixed by the Goal.\r\n### Example:\r\nIf you have:\r\n```\r\nAssumptions:\r\nh : P → Q\r\nGoal : Q\r\n```\r\nthen `apply h` will change your proof state to:\r\n```\r\nAssumptions:\r\nh : P → Q\r\nGoal : P\r\n```":
 "# 以下を示せばよい\r\n`P → Q`で`Q`を証明するには、`P`を示せば十分だ。\r\n### より一般に\r\n`P₁ → P₂ → P₃ → ... → Q`で`Q`を証明するには、`P₁, P₂, P₃, ...`を示せば十分だ。この主張が正しいことを自分自身に納得させる一つの方法は、`(P₁ → P₂ → Q) → (P₁ ∧ P₂ → Q)`を証明し任意の `(P₁ → P₂ → ... → Q) → (P₁ ∧ P₂ ∧ ... → Q)` に対して、そのような手順が存在することを自分自身に納得させることだ。\r\n### 実践において\r\nタクティク`apply`はゴールによって固定されていない前提の数だけ、サブゴールを作る。\r\n### 例:\r\nこんな状況なら：\r\n```\r\n仮定:\r\nh : P → Q\r\nゴール : Q\r\n```\r\nその時、`apply h`すると証明状態がこう変わる：\r\n```\r\n仮定:\r\nh : P → Q\r\nゴール : P\r\n```",
 "# Is it Cake!?\r\nThere's a show on TV about cake. It asks bakers to distinguish between every-day objects and cakes. This seems silly, because a cake is a cake.\r\n# Proposition Key:\r\n- `C` — This object is a Cake\r\n# Implication “ → ”\r\nYou'll notice that this time you don't have any assumptions. Fortunately, `C → C` is a tautology which means you can create an expression for the goal without any assumptions.\\\r\n\\\r\nIn this game, when you need to show an implication, you write a function. Creating a function requires an assumption and an expression. The assumption is introduced with two parts: `(n : P)` where `n` is any name of your choosing and the `P` is a well formed proposition.\\\r\n\\\r\nIt looks like this:\r\n```\r\nfun <name> : <Prop> => <expr>\r\nλ <name> : <Prop> ↦ <expr>\r\n```\r\nOften, when you're writting a function, the game will already know what proposition it's expecting. In such cases, the `<Prop>` becomes an optional part of the function.\r\n\r\n# A hint\r\nJust fill in the `<expr>` below:\r\n```\r\n-- Assuming h is evidence for C,\r\n-- write an expression for evidence of C\r\nexact λ h : C ↦ <expr>\r\n```":
 "# ケーキ！？\r\nテレビでケーキの番組をやっているんだ。日常品とケーキを区別することをパン職人に求めているんだ。ケーキはケーキなのだから、これは馬鹿げているよ。\r\n# 命題キー:\r\n- `C` — これはケーキだ\r\n# 含意 “ → ”\r\n今回、仮定が何もないことに気づくでしょう。幸いなことに、`C → C`はトートロジーなので、何の仮定もなしにゴールの式を作ることができます。\r\n\r\nこのゲームでは、あなたは含意を示したいとき、あなたは関数を書きます。関数を作るには仮定と式が必要です。仮定は2つの部分で導入されます：`(n : P)`ここで、`n`はあなたが選んだ任意の名前で、`P`はうまく形成された命題です。\r\n\r\nそれはこのように見えます：\r\n```\r\nfun <name> : <Prop> => <expr>\r\nλ <name> : <Prop> ↦ <expr>\r\n```\r\n多くの場合、関数を書いているとき、ゲームはすでにどのような命題を期待しているかを知っています。このようなケースでは、`<Prop>`は関数の必須でない部分になります。\r\n\r\n# ヒント\r\n以下の `<expr>`を埋めてください：\r\n```\r\n-- 仮定hはCの証拠です、\r\n-- Cの証拠となる式を書きましょう\r\nexact λ h : C ↦ <expr>\r\n```",
 "# Is Riffin bringing something?\r\nRiffin is an artsy, but rather eccentric friend of yours.\\\r\n\\\r\nEver since you asked Riffin to bring something to your party, he's been sending you rather cryptic emails. Initially, these emails seemed to have nothing to do with the party. However, after receiving the 5th email, you believe you might be able to use them to create evidence that Riffin is bringing something to the party.\\\r\n\\\r\nThese are the emails you received:\r\n1. If you're planning a party then the quest has begun\r\n2. If the quest has begin then the road to victory is long and winding\r\n3. If the quest has begun then it's time to get serious\r\n4. If the starting gun has fired then it's time to get serious\r\n5. If it's time to get serious then I'll bring a unicorn snack to the party\r\n\r\nYou still have your todo list as evidence that you're planning a party. Will it be enough?\r\n# Proposition Key:\r\n- `P` — You're **P**lanning a party\r\n- `Q` — The **Q**uest has begun\r\n- `R` — The **R**oad to victory is long and winding\r\n- `S` — The **S**tarting gun has fired\r\n- `T` — It's **T**ime to get serious\r\n- `U` — Riffin is bringing a **U**nicorn snack\r\n# Evidence\r\nSometimes visuals can make a logical argument much easier to digest. Here is a diagram you've drawn depicting Riffin's notes so far.\r\n$$\r\n\\begin{CD}\r\n  P  @>{h₁}>> Q       @>{h₂}>> R \\\\\r\n  @.         @VV{h₃}V           \\\\\r\n  S  @>>{h₄}> T       @>>{h₅}> U\r\n\\end{CD}\r\n$$\r\n# Reminder\r\nThe Precedence definition page explains that function application is left-associative. So these 2 are the same:\r\n- `h₁ h₂ h₃ h₄ h₅`\r\n- `((((h₁ h₂) h₃) h₄) h₅)`":
 "# Riffin、何か持ってきた？\r\nRiffinは、芸術的な趣味を持つが、やや奇抜なあなたの友です。\r\n\r\nあなたがRiffinにパーティーに何かを持ってくるように頼んで以来、彼はあなたにかなり謎めいたメールを送ってくるようになりました。 当初、これらのメールはパーティーとは無関係のように見えました。しかし、5通目のメールを受け取った後、あなたはそれらを証拠として使い、Riffinが何かをパーティーに持ってきてることを示すことができるかもしれないと考えるようになります。\r\n\r\n 以下が、あなたが受け取ったメールです:\r\n1. パーティーを計画しているなら、冒険はすでに始まっています。\r\n2. 冒険が始まったなら、勝利への道は長く曲がりくねったものとなります。\r\n3. 冒険が始まったなら、本気になる時です。\r\n4. スタートの合図が鳴ったなら、本気になる時です。\r\n5. 本気になる時が来たら、私はユニコーンスナックをパーティーに持ってきます。\r\n\r\nあなたはまだToDoリストを持っていて、それがパーティーを計画している証拠です。それだけで十分でしょうか？\r\n# 命題キー:\r\n- `P` — あなたはパーティーを計画している\r\n- `Q` — 冒険は始まった\r\n- `R` — 勝利への道は長く曲がりくねったものだ\r\n- `S` — スタートの合図は鳴った\r\n- `T` — 真剣になるときだ\r\n- `U` — Riffinはユニコーンスナックを持ってくる\r\n# 証拠\r\n視覚的な表現は、論理的な主張をはるかに理解しやすくすることがあります。以下は、あなたが描いた、Riffinのこれまでのメモを表現した図です。\r\n$$\r\n\\begin{CD}\r\n  P  @>{h₁}>> Q       @>{h₂}>> R \\\\\r\n  @.         @VV{h₃}V           \\\\\r\n  S  @>>{h₄}> T       @>>{h₅}> U\r\n\\end{CD}\r\n$$\r\n# リマインダー\r\nPrecedenceのページでは、関数の適用は左結合であると説明されています。したがって、次の2つは同じです。\r\n- `h₁ h₂ h₃ h₄ h₅`\r\n- `((((h₁ h₂) h₃) h₄) h₅)`",
 "# Introduction\r\nYou've made a todo list, so you've begun to plan your party.\r\n## Proposition Key:\r\n`P` — You're **P**lanning a party\r\n## Assumptions\r\n`todo_list : P` — Can be read as “The `todo_list` is evidence that you're `P`lanning a party”\r\n# The Exact Tactic\r\nThe Exact tactic is — for now — the means through which you give the game your answer. It's your way of declaring that you're done. In this level, you're just going to be using one of the assumptions directly, but as you learn how to form expressions the `exact` tactic will accept those too.\\\r\n\\\r\nThe input will look like `exact e` where `e` is an expression the game will accept for the current Goal.\\\r\n\\\r\n⋆Spoilers!⋆ If you enter “`exact todo_list`,” you will have completed this level.\r\n\r\n# Become Familiar with the User Interface!\r\n\r\n# Proof State\r\nFound in the middle bottom of the screen, the proof state tells you what objects exist, what assumptions are available, and what goal proposition you're trying to exhibit evidence for. Find the area of the screen with **Objects**, **Assumptions**, and **Goal**. I'll describe each shortly here.\r\n## 1. Objects:\r\nIn this level, you'll notice that there is only one proposition. `P : Prop` is the game's way of telling you that it knows that `P` is a proposition. You can check out the **Proposition Key** above to learn what it's denoting in this level if you're interested.\r\n## 2. Assumptions:\r\nMost levels will give you some starting assumptions that take the form of evidence for some propositions. The shorthand for a proposition traditionally starts with a capital letter and the shorthand for evidence traditionally starts with a lowercase letter.\r\n## 3. Goal:\r\nThe goal is always a proposition that you want to exhibit some evidence for. In this level, one of your assumptions already contains evidence for the goal. That will certainly not always be the case.\r\n# Inventory\r\nOn the right of the screen is your inventory of tactics, definitions, and theorems. Once unlocked, you can click them to read about what they do.":
 "# はじめに\nあなたはTodoリストを作り、パーティーの計画を立て始めました。\n## 命題キー:\n`P` — あなたはパーティーを計画している(**P**lanning)\n## 仮定\n`todo_list : P` — `todo_list`は`P`の証拠であるとも読めます。\n# タクティク Exact\nタクティク Exactは — 今のところ — あなたがゲームに答えを与える方法です。これは「これで終わり」と宣言する方法です。\nこのレベルでは、 あなたは1つの仮定を直接使うだけですが、 式の作り方を学んだ時、タクティク `exact`はそれらも受け入れるでしょう。.\n\n入力は `exact e` のようになり、`e`はゲームが現在のゴールとして受け入れる式です。\n\n⋆ネタバレ！⋆ 「`exact todo_list`」と入力すれば、このレベルをクリアできるでしょう。\n\n# インターフェースに慣れよう！\n\n# 証明状態\n画面中央の下にある、「証明状態」はあなたに、どんな対象があり、どんな仮定が使え、そしてあなたがどんな命題を証明しようとしているのか教えてくれます。\n**オブジェクト**、 **仮定**、そして **ゴール**と書かれているエリアを見つけてください。ここでそれぞれ簡潔に説明します。.\n## 1. オブジェクト:\nこのレベルでは,一つの命題しかないことに気づくでしょう。 `P : Prop`は、ゲームが`P`を命題だと知っていることを表しています。 \nもし興味があるなら、上の**命題キー**をチェックし、それがこのレベルで何を示しているか学んでみてください。\n## 2. 仮定:\nほとんどのレベルは初期状態で、「ある命題に対する証拠」という形をとる仮定をいくつか与えるでしょう。\n命題の省略形は伝統的に大文字で始まり、証拠の省略形は伝統的に小文字で始まります。\n## 3. ゴール:\nゴールは常に、あなたが何らかの証拠を示したい命題です。このレベルでは、仮定の一つがすでにゴールの証拠を含んでいます。もちろん、これがいつもそうだとは限りません。\n インベントリ\n画面の右側にあるのはあなたのタクティク、定義、そして定理のインベントリです。ロックが解除されたら、あなたはそれらをクリックして何をするか読むことができます。",
 "# Intro\r\nRemember how `λx y ↦ ...` is just shorthand for `λx ↦ λy ↦ ...`? Well, the `intro` tactic admits the same shorthand:\r\n```\r\nintro p q\r\n```\r\nis just shorthand for\r\n```\r\nintro p\r\nintro q\r\n```":
 "",
 "# In this world\r\nIn this world, you'll be introduced to negation — which is written with the “`¬`” symbol.\\\r\n\\\r\nThis operator is really just syntactic sugar. `¬P` means `P → False`. It seamlessly integrates into all the scenarios where implications are used. It's also constructed using functions (`λ...↦...`) just like any other implication.\\\r\n\\\r\nThe new interesting element for this world is `False`. What is `False`? It's a proposition — part of the set of statements that can be either true or false. Importantly, however it's defined as a proposition which always happens to be false. By sheer force of definition — there can never exist any evidence supporting the veracity of `False`.\\\r\n\\\r\nConsider a real-world analogue like “Tom is an experienced beginner” or “Tom is a married bachelor”, neither can ever be true. For there to exist evidence of either, you need to throw out definitions of the words themselves.\\\r\n\\\r\nAn interesting corollary arises: from the premise of `False`, any proposition becomes permissible. If you're allowed to speak in gobbledygook, then you can say anything!\r\n### Garbage In, Garbage out\r\nImagine you're signing a contract of utmost importance. The terms stipulate: “Once per day, you will be given a whole number greater than 0. If the number falls below 100, you must gracefully wave your left hand; if it exceeds 90, your right hand should elegantly sway. Lastly, if the number plunges below 0, you must transform into a cucumber.”\\\r\n\\\r\nOn casual scrutiny, one might naively conclude that adhering to this contract may involve turning into a cucumber. While that may seem impossible, a subtle loophole exists. By astutely arguing that the contract will never demand the impossible act of becoming a cucumber, you can effectively assure your compliance.\\\r\n\\\r\nBy signing the contract, you're agreeing that “If there appears a number that is both greater than 0 and less 0, then I will transform into a cucumber.” Your grandiose claims remain secure as they hinge on an eventuality that defies logical possibility.":
 "",
 "# Go buy chips and dip!\r\n- If you go shopping, then you'll buy chips.\r\n- If you go shopping, then you'll buy dip.\r\n- ∴ If you go shopping, you'll buy chips and dip\r\n# Proposition Key:\r\n- `C` — You buy chips\r\n- `D` — You buy dip\r\n- `S` — You go shopping":
 "# チップスとディップを買おう！\r\n- 買い物に行けば、チップスを買うでしょう。\r\n-買い物に行けば、ディップを買うでしょう。\r\n- ∴ 買い物に行けば、チップスとディップを買うでしょう。\r\n# 命題キー:\r\n- `C` — チップスを買う\r\n- `D` — ディップを買う\r\n- `S` — 買い物に行く",
 "# Function Application/Implication Elimination\r\n`P → Q` is propostion given to functions from evidence of `P` to evidence of `Q`.\r\n# Juxtaposition\r\nJuxtaposition just means “to place next to each other,” which is what we'll do to give a parameter to a function.\r\n### Example\r\n```\r\n-- Assumptions\r\ne₁ : P\r\ne₂ : Q\r\nGoal:\r\nP ∧ Q\r\n```\r\n----\r\n```\r\nexact (and_intro e₁ e₂)\r\n```\r\n### Example\r\n```\r\n-- Assumptions\r\na : A\r\nh₁ : A → B\r\n-- Goal\r\nB\r\n```\r\n---\r\n```\r\nexact (h₁ a)\r\n```\r\nTakes `h₁` and applies `a` to it.":
 "# 関数適用/含意除去\r\n`P → Q` は `P` の証拠から `Q` の証拠への関数に与えられる命題である。\r\n# Juxtaposition\r\nJuxtaposition（並置）とは「隣同士に置く」という意味であり、これは関数にパラメータを与えるために行うことである。\r\n### 例\r\n```\r\n-- 仮定\r\ne₁ : P\r\ne₂ : Q\r\n-- ゴール:\r\nP ∧ Q\r\n```\r\n----\r\n```\r\nexact (and_intro e₁ e₂)\r\n```\r\n### 例\r\n```\r\n-- 仮定\r\na : A\r\nh₁ : A → B\r\n-- ゴール\r\nB\r\n```\r\n---\r\n```\r\nexact (h₁ a)\r\n```\r\n`h₁`を受け取り、それに`a`を適用する。",
 "# Follow the Graph Backwards\r\n$$\r\n\\begin{CD}\r\n  P  @>{h₁}>> Q       @>{h₂}>> R \\\\\r\n  @.         @VV{h₃}V           \\\\\r\n  S  @>>{h₄}> T       @>>{h₅}> U\r\n\\end{CD}\r\n$$":
 "# グラフを逆方向にたどる\r\n$$\r\n\\begin{CD}\r\n  P  @>{h₁}>> Q       @>{h₂}>> R \\\\\r\n  @.         @VV{h₃}V           \\\\\r\n  S  @>>{h₄}> T       @>>{h₅}> U\r\n\\end{CD}\r\n$$",
 "# Final `∨` Tactic Level\r\nThis level uses most of the tactics you've learned so far.":
 "",
 "# False\r\nThis is a proposition for which there can never be any evidence. If your assumptions lead you to evidence for `False`, then your assumptions are inconsitent and you can use `false_elim` to deduce any proposition you like.":
 "",
 "# False\r\nOnce your goal is false, then you can `apply h`": "",
 "# Enjoy ⌣": "",
 "# Either way.\r\nChocolate chip oatmeal cookies, which ingredient goes first?\r\n1. Oatmeal or chocolate chips?\r\n2. Chocolate chips or oatmeal?\r\n# Proposition Key:\r\n- C — Chocolate chips\r\n- O — Oatmeal\r\n\r\nThis time they're not under assumptions, but you have the evidence in your inventory.\r\n- `or_inr : C → O ∨ C`\r\n- `or_inl : O → O ∨ C`":
 "# どちらにせよ\r\nチョコチップオートミールクッキー、どの材料から入れる？\r\n1. オートミールかチョコチップ？\r\n2. チョコチップかオートミール？\r\n# 命題キー:\r\n- C — チョコチップ\r\n- O — オートミール\r\n\r\n今回は仮定ではなく、インベントリの証拠を使います。\r\n- `or_inr : C → O ∨ C`\r\n- `or_inl : O → O ∨ C`",
 "# Disjunction\r\n## Introduction\r\nAn “Or” like `h : P ∨ Q` can be introduced in two ways:\r\n1. If you have `p : P`, you can use `or_inl p`\r\n2. If you have `q : Q`, you can use `or_inr q`\r\n\r\nIn either case, remember that the other type in your disjunction must be inferable in context or supplied as part of the expression. For example: `(or_inl p : P ∨ Q)`\r\n## Elimination\r\nAn “Or” like `h : P ∨ Q` can be be eliminated if both P and Q imply the same proposition. In this example, P or Q implies R:\r\n```\r\n-- Assumptions\r\npvq: P ∨ Q\r\npr : P → R\r\nqr : Q → R\r\n-- Goal: R\r\nexact or_elim pvq pr qr\r\n```":
 "",
 "# Definitely Not\r\nYour cake order definitely has sprinkles, which means it's **not** missing sprinkles and loaded with chocolate chips\r\n# Proposition Key:\r\n- `C` — The cake is loaded with chocolate chips\r\n- `S` — The cake is topped with sprinkles":
 "",
 "# Curry\r\nIf you've got chips and dip, then you've got a popular party snack! This is undeniable.\\\r\n\\\r\nTherefore if you've got chips, then if you've got dip, then you've got a popular party snack.\r\n# Proposition Key:\r\n- `C` — You've got chips\r\n- `D` — You've got Dip\r\n- `S` — You've got a popular party snack":
 "# カリー\r\nチップスとディップがあれば、人気のパーティーおやつの完成です！これは疑いようのない事実です。\r\n\r\nしたがって、チップスがある時、ディップがあるなら、人気のパーティーおやつの完成です。\r\n# 命題キー:\r\n- `C` — チップスがある\r\n- `D` — ディップがある\r\n- `S` — 人気のパーティーおやつがある",
 "# Coupled Conditionals\r\nSybeth and Alarfil are a couple. In effect, this means that if Sybeth is playing a party game, then Alarfil is playing too and vice versa. Therefore Sybeth is playing Charades if and only if Alarfil playing.\r\n# Proposition Key:\r\n- J — Alarfil is playing Charades\r\n- S — Sybeth is playing Charades\r\n# Unlocked `↔ intro`\r\nAssuming `e₁ : P → Q` and `e₂ : Q → P`, you can introduce a biconditional with `have h := iff_intro e₁ e₂`, though the anonymous constructor syntax works just like it does for conjunctions: `have h : P ↔ Q := ⟨e₁, e₂⟩`":
 "",
 "# Contradiction\r\nThis level introduces a relatively powerful tactic. Contradiction is a finishing tactic that will look through your assumptions and discharge some of the more obvious contradictions in order to solve any goal.\\\r\n\\\r\nexamples:\r\n  1. `h : False` says `h` is evidence for `False` which is a contradiction\r\n  2. `h₁ : P` and `h₂ : ¬P` says that P is true and not true at the same time. This is also a contradiction.":
 "",
 "# Constructor\r\nWhenever there's a clear way to create new evidence **that matches the goal**, the constructor tactic will pick that for you. This replaces the current goal with one or more goals that together complete the construction.\\\r\n\\\r\nFor this level, your goal is `P ∧ Q`. The `constructor` tactic will replace that goal with two separate subgoals. This is likely the first time you've seen two goals in your proof state. First you'll need to show evidence for `P`, then you'll need to show evidence for `Q`.":
 "# Constructor\r\n**ゴールに合致する**新たな証拠を作り出す明確な方法があればいつでも、 タクティク `constructor` がそれを選んでくれる。 これは、現在のゴールを、一緒にコンストラクトを完成させる1つ以上のゴールに置き換えるものである。\r\n\r\n このレベルでは、ゴールは`P ∧ Q`だ。タクティク`constructor`はそのゴールを別々のサブゴール2つに置き換える。証明状態で2つのゴールを見るのは、これが初めてだろう。あなたはまず`P`の証拠を示す必要があり、その後あなたは`Q`の証拠を示す必要がある。",
 "# Constructor\r\nWhenever there's a clear way to create new evidence **that matches the goal**, the constructor tactic will pick that for you. This replaces the current goal with one or more goals that together complete the construction.\r\n\r\nFor example, if your goal is `P ∧ Q` then the `constructor` tactic will replace that goal with two separate subgoals. First you'll need to show evidence for `P`, then you'll need to show evidence for `Q`.":
 "# Constructor\r\n**ゴールに合致する**新たな証拠を作り出す明確な方法があればいつでも、 タクティク `constructor` がそれを選んでくれる。 これは、現在のゴールを、一緒にコンストラクトを完成させる1つ以上のゴールに置き換えるものである。\r\n\r\n 例えば、もしあなたのゴールが`P ∧ Q`ならタクティク`constructor`はゴールを別々のサブゴール2つに置き換える。あなたはまず`P`の証拠を示す必要があり、その後あなたは`Q`の証拠を示す必要がある。",
 "# Conjunction/Biconditional\r\n`cases` will deconstruct an `∧` or an `↔` into it's parts, removing the assumption and replacing it with two new assumptions.\r\n# Disjunction\r\nUsed with an `∨` cases will split the main goal, replacing it with a goal for each of the two possibilities.":
 "# 論理積/同値\r\n`cases`は`∧`または`↔`を分解し、仮定を取り除き、2つの新しい仮定に置き換える。\r\n# 論理和\r\n`∨`の場合に使うと、メインゴールが分割され、あり得る状態2つそれぞれに対するゴールで置き換える。",
 "# Conjunction\r\n## Introduction\r\nAn “And” can be introduced with the `and_intro` theorem. Conjunctions and biconditionals can both be constructed using the angle bracket notation as well.\r\n### Examples\r\n```\r\n-- Assumptions\r\np : P\r\nq : Q\r\n-- Each new term is evidence for P ∧ Q\r\n-- Explicit Constructer, no annotations needed\r\nhave h₁ := and_intro p q\r\nhave h₂ := and_intro (left := p) (right := q)\r\n-- Implicit Constructuer, annotations based on context\r\n-- Type these angle brackets with “\\<” and “\\>”\r\nhave h₆ : P ∧ Q := ⟨p,q⟩\r\nhave h₇ := (⟨p,q⟩ : P ∧ Q)\r\n```\r\n## Elimination\r\nAn “And” like `h : P ∧ Q` can be reduced in two ways:\r\n1. Aquire evidence for `P` using `and_left h` or `h.left`\r\n2. Aquire evidence for `Q` using `and_right` or `h.right`":
 "",
 "# Cases again\r\nSimilar to last level.": "# 再・cases\r\n前レベルと同様。",
 "# Carry On Effects\r\nIf the cake arrives, then everybody will rejoice. Either the cake arrives or you get a refund. Therefore, either everybody will rejoice or you get a refund! That's a win-win situation.\r\n# Proposition Key:\r\n- C — The cake arrives\r\n- J — Everybody is joyful\r\n- R — You get a refund":
 "# 継続的効果\r\nケーキが届いたら、皆喜ぶでしょう。ケーキが届かなかったら、返金されるでしょう。ですから、皆喜ぶか、返金されます！ウィンウィンの状況ですね。\r\n# 命題キー:\r\n- C — ケーキが届いた\r\n- J — 皆喜ぶ\r\n- R — 返金される",
 "# Biconditional\r\n## Introduction\r\nAn “If and only if” can be introduced with the `iff_intro` theorem. Biconditionals and conjunctions can both be constructed using the angle bracket notation as well.\r\n### Examples\r\n```\r\n-- Assumptions\r\nh₁ : P → Q\r\nh₂ : Q → P\r\n-- Each new term is evidence for P ↔ Q\r\n-- Explicit Constructer, no annotations needed\r\nhave h₁ := iff_intro h₁ h₂\r\nhave h₂ := iff_intro (mp := h₁) (mpr := h₂)\r\n-- Implicit Constructuer, annotations based on context\r\n-- Type these angle brackets with “\\<” and “\\>”\r\nhave h₆ : P ↔ Q := ⟨h₁, h₂⟩\r\nhave h₇ := (⟨h₁, h₂⟩ : P ↔ Q)\r\n```\r\n## Elimination\r\nAn “If and only if” like `h : P ↔ Q` can be reduced in two ways:\r\n1. Aquire evidence for `P → Q` using `iff_mp h` or `h.mp`\r\n2. Aquire evidence for `Q → P` using `iff_mpr h` or `h.mpr`\r\n## Rewrite\r\nBiconditionals let you use the `rewrite` tactic to change goals or assumptions.":
 "",
 "# BOSS Level\r\n\"Is it possible that if this is the cake you bought, then it's gonna taste horrible?\"\\\r\n\"I'm certain that's not possible!\"\\\r\n\"Oh, so what you're saying is that you have evidence that this is not not the cake you bought.\"\r\n# Proposition Key:\r\n- `B` — You bought this cake\r\n- `C` — The cake tastes horrible":
 "",
 "# BOSS LEVEL!!!\r\n# Uncertain Snacks\r\nSybeth wants to know whether Riffin will still bring a snack, regardless of whether she brings one herself or not.\\\r\n\\\r\nShe's asked you for evidence that:\r\n- **If** Riffin is bringing a snack **then**\r\n  1. Her bringing a snack **implies** Riffin is bringing a snack\r\n  2. Her not bringing a snack **implies** Riffin is bringing a snack\r\n\r\nThat's a bit convoluted, but you should be able to produce some evidence of this!\r\n# Proposition Key:\r\n- `R` — Riffin is bringing a snack\r\n- `S` — Sybeth is bringing a snack":
  "# ボスレベル！！！\r\n# 不確かなスナック\r\nSybeth は、自分がスナックを持ってくるかどうかに関わらず、Riffinがスナックを持ってくるかどうか知りたいです。\r\n\r\n彼女はあなたに証拠を求めました：\r\n- **もし**Riffinがスナックを持ってくる**場合**、\r\n  1. 彼女がスナックを持ってくることはRiffinがスナックを持ってくることを**含意**します\r\n 2. 彼女がスナックを持ってこないことはRiffinがスナックを持ってくることを**含意**します\r\n\r\nそれは少し複雑ですが、その証拠を示せるはずです！\r\n# 命題キー:\r\n- `R` — Riffinはスナックを持ってくる\r\n- `S` — Sybethはスナックを持ってくる",
 "# BOSS LEVEL\r\nThis is an involved level. Tactics can be especially helpful in that much of the bookkeeping is done on your behalf. Good luck.\r\n\r\nThere are no restrictions this level. Use everything you've learned.":
 "",
 "# BOSS LEVEL\r\nThis is an involved level. It doesn't require you to do anything tricky, but there are a lot of moving parts and it is easy to lose track of what you're doing.\\\r\n\\\r\nI recommend editor mode. Think about what this is asking you to prove and use `have` to give yourself any auxiliary facts that don't exist under your theorems.":
 "",
 "# BOSS LEVEL\r\nThe trick for this level is to pull out the relevant info from the assumption `h` before moving on, otherwise you'll need to re-do that work for each sub-goal.\r\n\r\nI use the `cases` tactic 5 times and for me, they're the first five tactics for this level.":
"# BOSS LEVEL\r\nこのレベルのコツは、次に進む前に仮定`h`から関連情報を引き出すことだ。そうしないとサブゴールごとにその作業をやり直す必要がある。\r\n\r\n私はタクティク`cases`を5回使っており、私にとってそれらはこのレベルでの最初の5つのタクティクだ。",
 "# BOSS LEVEL\r\nIf you can finish this level, you've certainly mastered the `∧`. There's no deep logical tricks in this boss level, you've just got to know how to work at properly unnesting and then building the right Proposition.\\\r\n\\\r\nUsing the `have` tactic, you can break this task down into digestible chunks. The top right of the screen has a button that toggles between editor mode and typewriter mode. Editor mode is often a bit easier to work with as it allows you to enter multi-line expressions or edit earlier lines seamlessly. While in editor mode, the proof state will change depending on which line your caret is on.\r\n# Rearranging Boxes\r\nFinally, a bunch of your invites have returned with RSVPs. The mailman has delivered them in a big box. Make a list of the expected attendees so far.\r\n# Proposition Key:\r\n- A — **A**larfil is coming to the party\r\n- C — **C**yna** is coming to the party\r\n- I — **I**lyn** is coming to the party\r\n- O — **O**rin** is coming to the party\r\n- P — **P**ippin** is coming to the party\r\n- S — **S**ybeth** is coming to the party\r\n- U — **U**riel** is coming to the party":
 "# BOSS LEVEL\r\nこれがクリアできるなら,あなたは確かに`∧`をマスターしています。このボスレベルには深い論理的なトリックはありません、適切に入れ子を外し、適切な命題を構築する方法を知らなければなりません。\r\n\r\n`have`タクティクを使えば、このタスクを分解してわかりやすくすることができます。画面右上には、エディターモードとタイプライターモードを切り替えるボタンがあります。エディターモードでは、複数行の式を入力したり、前の行をシームレスに編集したりできるので、作業が少し楽になることが多いです。エディターモードでは、証明状態は、キャレットがどの行にあるかによって変化します。\r\n# 箱を並べ替える\r\nようやく、招待状の束がRSVP(お返事下さい、の意)とともに戻ってきました。郵便屋さんが大きな箱に入れて届けてくれました。これまでの参加予定者のリストを作成しましょう。\r\n# 命題キー:\r\n- A — **A**larfilがパーティーに来る\r\n- C — **C**ynaがパーティーに来る\r\n- I — **I**lynがパーティーに来る\r\n- O — **O**rinがパーティーに来る\r\n- P — **P**ippinがパーティーに来る\r\n- S — **S**ybethがパーティーに来る\r\n- U — **U**rielがパーティーに来る",
 "# BOSS LEVEL\r\nIf we summon the Kraken, then we shall assuredly perish. While that might sound ominous, consider this: if we summon the Kraken or **have icecream**, then we shall **have icecream!** or we shall perish.\r\n# Proposition Key:\r\n- I — **We have have icecream!**\r\n- K — We summon the Kraken\r\n- P — We shall assuredly perish":
 "# BOSS LEVEL\r\nクラーケンを召喚したら、私たちは滅びるでしょう。それは不穏に聞こえるかもしれないけど、考えてみてください：もしクラーケンを召喚するか**アイスクリームを食べる！** なら、**アイスクリームを食べる！**...か滅びるでしょう。\r\n# 命題キー:\r\n- I — **アイスクリームを食べる！**\r\n- K — クラーケンを召喚する\r\n- P — 私たちは必ず滅びる",
 "# Another self-contradiction\r\nIf you try to `apply h` right away, you'll be stuck. You'll have to try something else first.\\\r\n\\\r\nOnce your goal is to show `False`, then `apply h` seems to do something funny. It asks you to show evidence for the same goal twice. If you try to apply `P → Q → R → S` to a Goal of `S`, then apply will make you prove each parameter separately — resulting is the three sub-goals of showing `P`, showing `Q`, and showing `R`.\\\r\n\\\r\nIn this level, `apply h` is applying `P → P → False` to a goal of `False`, so it follows that you'll need to show evidence for `P` twice.":
 "",
 "# Another Unlock\r\nCan you figure this one out?": "# もう一つの解禁\r\n分かるかな？",
 "# Anonymous intro\r\nYou've likely tried this already, but you can use `intro` without following it with any identifiers.":
 "",
 "# And Another One\r\nReverse the implication you proved last level.\r\n# More about `apply`\r\nWhat this level is showing is that you can think about `h` as a function with 2 parameters instead of a function that returns a function. The `apply` tactic implicitly understands this point of view.\\\r\n\\\r\nOnce your goal is `R`, you can `apply h`. This is like saying “in order to prove R, it suffices to prove `P` and prove `Q`”. You'll notice that `apply` automatically creates the two goals for you in such cases.\\\r\n\\\r\n**Aside:** When you've been using `constructor` to build conjunctions, this has been the same thing as if you had used `apply and_intro`. You can try that out next level if you're so inclined.":
 "# そしてもう一つ\r\n前のレベルで証明した含意を逆転させよう。\r\n# `apply`についてもっと\r\nこのレベルが表しているのは、`h`を関数を返す関数ではなく、2つの引数を持つ関数として考えることができるということだ。タクティク`apply`は、この点を暗黙的に理解している。\r\n\r\n目標が `R` になったら、`apply h`できる。これは「Rを証明するためには、Pを証明し、Qを証明すれば十分である」と言っているようなものだ。このような場合、`apply`は自動的に2つのゴールを作る。\r\n\r\n**補足:**`constructor`を使い論理積を構築した場合、それは`apply and_intro`を使った場合と同じことになる。興味があれば、次のレベルで試してほしい。",
 "# An Introduction to Constructive Logic\r\nThis is a game about evidence [¹] and propositions.\r\n\r\nTo play this puzzler you'll need to learn some notation. Unlike learning how to do a crossword or solve a Sudoku, the notation is a bit more involved. As the levels progress, you will — in effect — be learning a small part of a programming language. Just enough to prove (or construct evidence for) propositions and predicates.\r\n\r\nBelow, you're provided with a whirlwind tour of the notation at play as well as a bit of motivation for why the notation looks the way it does. This is all done through a single example. Many of the details will seem lacking; The concepts covered here will be addressed with more detail during the tutorial worlds of this game.\r\n\r\n# Redux\r\n\r\nEach tutorial world is accompanied by a **Redux World** with the same subtitle. These worlds are optional, don't have any flavor text, and challenge you to solve the exact same set of levels in a different way. These worlds probably do not belong in a puzzle game, but I found the exercise helpful in garnering a computer-sciencey intuition about the interplay between proof terms and tactics in Lean 4.\r\n\r\n# Building some notation\r\nConsider the following argument stated in natural language:\r\n\r\n“Either cat fur or dog fur was found at the scene of the crime. If dog fur was found at the scene of the crime, Officer Thompson had an allergy attack. If cat fur was found at the scene of the crime, then Macavity is responsible for the crime. But Officer Thompson didn’t have an allergy attack, and so therefore Macavity must be responsible for the crime.” [[ˢʳᶜ](https://iep.utm.edu/propositional-logic-sentential-logic/#H5)]\r\n\r\nDoes this argument convince you? The validity of this argument can be made more obvious by representing the chain of reasoning leading from the premises to the conclusion:\r\n1. Either cat fur was found at the scene of the crime, or dog fur was found at the scene of the crime. (Premise)\r\n2. If dog fur was found at the scene of the crime, then Officer Thompson had an allergy attack. (Premise)\r\n3. If cat fur was found at the scene of the crime, then Macavity is responsible for the crime. (Premise)\r\n4. Officer Thompson did not have an allergy attack. (Premise)\r\n5. Dog fur was not found at the scene of the crime. (Follows from 2 and 4)\r\n6. Cat fur was found at the scene of the crime. (Follows from 1 and 5)\r\n7. Therefore Macavity is responsible for the crime. (Follows from 3 and 6)\r\n\r\nIf you take a moment to re-read them again, lines 5, 6, & 7 are all slightly different styles of logical deductions.\r\n\r\n- Line 5 is deducing the negation of the left-hand side of an \"if ... then ...\" statement. Just for references' sake, we'll give this style of reasoning a name: [**modus tollens**](https://en.wikipedia.org/wiki/Modus_tollens)\r\n- Line 6 is using the process of elimination on two options. This is the style of reasoning responsible for Sherlock Holmes' most famous quote — \"When you have eliminated the impossible, whatever remains, however improbable, must be the truth\". We'll give this a name too: [**modus tollendo ponens**](https://en.wikipedia.org/wiki/Modus_ponendo_tollens)\r\n- Line 7 is the conclusion and is applying the \"if ... then ...\" statement on line 3. We'll call this one [**modus ponens**](https://en.wikipedia.org/wiki/Modus_ponens).\r\n\r\nWe won't always be denoting these with Latin names, but the general process of being able to give some generically useful deductive reasoning a name is nice. It makes them easier to reference. During the course of this game some of your proofs will be given names and correspondingly unlocked in your inventory. Thus names are a way to avoid proving the same thing over and over again.\r\n\r\n# Propositions\r\nIf we separate out the 4 true/false statements required for our line of reasoning and introduce some connectives, we can see the exact same argument in a more concise form. The numbers 1 - 7 here are meant to match exactly with the natural language above.\r\n\r\nWe're going to give our English connectives some symbols:\r\n- \"and\" — \"∧\"\r\n- \"implies\" — \"→\"\r\n- \"not\" — \"¬\"\r\n- \"or\" — \"∨\"\r\n\r\nand we'll give our propositions some symbols:\r\n- C — Cat fur was found at the scene\r\n- D — Dog fur was found at the scene\r\n- M — Macavity is responsible for the crime\r\n- T — Officer Thompson had an allergy attack.\r\n\r\nThese symbols let us write out the argument from above as follows:\r\n1. C ∨ D (Premise)\r\n2. D → T (Premise)\r\n3. C → M (Premise)\r\n4. ¬T (Premise)\r\n5. ¬D (Modus tollens on 2 and 4)\r\n6. C (Modus tollendo ponens on 1 and 5)\r\n7. M (Modus ponens on 3 and 6)\r\n8. Therefore M (The Conclusion)\r\n\r\nTake a moment to see if you can match up the propositions and their meanings with the natural language versions above. If it feels unnatural right now, don't worry too much. This will become more natural as you progress.\r\n\r\n# Evidence\r\nThe argument above is pretty similar to a full formalization of the chain of reasoning. This game doesn't reference line numbers and doesn't allow free-floating hypothesis. Instead everything is given a name. The justification for introducing a new name will be an expression.\r\n\r\nHere's how this example might be expressed in the language of this game. It's a little different, but see if you can match this up with the argument as expressed above:\r\n\r\n```lean\r\n-- Objects\r\nC, D, M, T : Prop\r\n-- Assumptions\r\nh₁ : C ∨ D\r\nh₂ : D → T\r\nh₃ : C → M\r\nh₄ : ¬T\r\n```\r\n----\r\n```lean\r\n-- Chain of reasoning\r\nhave h₅ : ¬D := modus_tollens h₂ h₄\r\nhave h₆ : C := modus_tollendo_ponens h₁ h₅\r\nhave h₇ : M := modus_ponens h₃ h₆\r\n-- Goal (Conclusion)\r\nexact h₇\r\n```\r\n\r\nYou'll notice I have given each assumption and each step in the chain of reasoning names like `h♯` where `♯` matches up with the line numbers from before. That's just to put the example here in easy correspondence with the examples above.\r\n\r\n`h₁ : C ∨ D` is read out in english as `h₁` is evidence for the proposition `C ∨ D`. In this case, `h₁` is evidence given as part of the premise, so there's no `:= ...` expression afterwards.\r\n\r\nTo introduce new evidence — such as `h₅` — you need to write out an expression that the game can evaluate as evidence of the correct proposition. We'll introduce how to write these expressions throughout the tutorial worlds.\r\n\r\n`h₅` is evidence of `¬D` (that \"Dog fur was not found at the scene of the crime.\") and we know this by the expression `(modus_tollens h₂ h₄)`.\r\n\r\n# To start\r\n\r\nIn this game, each level will ask you to provide evidence of some proposition. This will often involve using the evidence you already have in some way.\r\n\r\nClick on the first world — **Party Invites** — to get started.\r\n\r\n----\r\n\r\n[¹] This game says “evidence” where other learning material may say “term”, “proof”, or neither (relying on context to differentate a proposition from its proof). I use *evidence* for this game in an effort to make the flavor text seem less at odds with the formalization.\\\r\n\\\r\n[ˢʳᶜ]Logic example taken from [IEP](https://iep.utm.edu/propositional-logic-sentential-logic/#H5) entry: *Propositional Logic*.":
 "",
 "# An Emergency!\r\nStop with the invites! Coco, your cat is stuck up a tree.\\\r\n\\\r\nThe firefighters are here but they need your help figuring if they can get to the branch with Coco. They can see the entire tree and they know how to follow the branches by going left or right at each intersection. If they can do that, then they must be able to get to Coco.\r\n# Proposition Key:\r\n- C — The firefighters can get to Coco\r\n- L — The firefighters can get to some leaves\r\n# Goal\r\nShow evidence that the firefighters can get to Coco\r\n\r\n# `∧` associates to the right\r\nCheck out the definition page for \"Precedence\" to learn a bit more.\r\n# Hint # 1\r\nIf you hover your mouse over an operator in the proof state it will highlight the part of the expression that it operates **on**. Find the one that highlights the entire expression to see where the trunk of the tree is.\\\r\n\\\r\nAnother approach is trial and error. Enter `have h₁ := h.right` to see `h₁: (L ∧ L) ∧ L` appear in your assumptions, which doesn't have `C` anywhere, indicating that this isn't the correct part of the tree. You can hit retry, then change that line to have `h₁ := h.left`. Then your assumptions will have `h₁: L ∧ ((L ∧ C) ∧ L) ∧ L ∧ L ∧ L`, which has the `C` somewhere.\r\n# Hint # 2\r\nThe |**Show more help!**| button below will display the expression for you. Beware, the boss level will not come with this option.":
 "# 緊急事態！\r\n招待は中断だ！あなたの猫、Cocoが木の上で立ち往生しています！\r\n\r\n消防士が来たけど、Cocoがいる枝まで行けるかどうか...君の助けが必要です。 彼らは木全体を見渡すことができ、分岐点ごとに左右に進んで枝をたどる方法を知っています。それができるのであれば、Cocoのところまで行けるに違いありません。\r\n# 命題キー：\r\n- C — 消防士がCocoにたどり着ける\r\n- L — 消防士がいくらかの葉にたどり着ける\r\n# ゴール\r\n消防士がCocoにたどり着ける証拠を示してください。\r\n\r\n# `∧`は右結合\r\n「Precedence」の定義ページを見て、もう少し知ってください。\r\n# ヒント1\r\n証明状態の演算子の上にマウスカーソルを置くと、その演算子が **作用** する式の部分がハイライトされます。木の幹がどこにあるのか、式全体をハイライトしているものを探してください。\r\n\r\nもう一つのアプローチは試行錯誤です。 `have h₁ := h.right`と入力すると仮定に`h₁: (L ∧ L) ∧ L`が現れ、`C`はこれのどこにもないため、これは木の正しい部分ではないことを示しています。リトライを押して、その行を次のように変更してくだい：`h₁ := h.left`。 すると、あなたの仮定は次のようになります：`h₁: L ∧ ((L ∧ C) ∧ L) ∧ L ∧ L ∧ L`、これには`C`があります。\r\n# ヒント2\r\n下にある|**Show more help!**|ボタンはあなたに式を表示します。注：ボスレベルにはないよ！",
 "# Allergy: Triple Confusion\r\nPippin is allergic to avocado. You tell him you're not *not* **not** bringing avocado!!! Pippin gives you a confused look, but after a moment of contemplation, he responds with, \"Ok, good to know.\"\r\n# Proposition Key:\r\n- `A` — You're bringing avocado":
 "",
 "# Allergy #2\r\nWe cannot have both Pippin and avocado at the party. Which means that if Pippin is attending, then there will not be any avocado.\r\n# Proposition Key:\r\n- `A` — There's avocado at the party\r\n- `P` — Pippin is attending the party":
 "",
 "# Allergy #1\r\nOwing to his allergy, if Pippin is present, there must be no avocado at the party. Which means that we cannot have both Pippin and avocado at the party\r\n# Proposition Key:\r\n- `A` — There's avocado at the party\r\n- `P` — Pippin is attending the party":
 "",
 "# A new way to use the `cases` tactic\r\nYou've used cases so far as a means to take apart conjunctions like `P ∧ Q`. The same tactic works a bit differently on disjunctions. When you use `cases h3`, you'll need to show `P` assuming Q and show `P` assuming `R`. Then the game will conclude that `P` is the case regardless of which of the disjunctions are true.":
 "# タクティク`cases`の新たな使い方\r\n今まで、`P ∧ Q`ような論理積を分解する手段として`cases`を使ってきた。同じタクティクは、論理和では少し違う働きをする。`cases h3`を使うと、仮定`Q`の元`P`を示し、仮定`R`の元`P`を示す必要がある。すると、論理和のどの部分が真でも、ゲームは`P`が成り立つと結論付ける。",
 "# A distribution of cookies\r\nYou can tell the cookies are either gingersnap cookies or they're a mix of shortbread cookies and sugar cookies.\r\n# Proposition Key:\r\n- G — They are gingersnap cookies\r\n- H — They are shortbread cookies\r\n- U — They are sugar cookies":
 "# クッキーの分配\r\nクッキーは、ジンジャースナップか、ショートブレッドとシュガークッキーのミックスであると言うことができます。\r\n# 命題キー:\r\n- G — それらはジンジャースナップクッキーです\r\n- H — それらはショートブレッドクッキーです\r\n- U — それらはシュガークッキーです",
 "# A distribution of cookies\r\nYou can tell from the aroma that there are are gingersnap cookies. There's another smell there too. Could be shortbread cookies or sugar cookies.\r\n# Proposition Key:\r\n- G — They are gingersnap cookies\r\n- H — They are shortbread cookies\r\n- U — They are sugar cookies":
 "# クッキーの分配\r\nジンジャースナップクッキーの匂いがします。他の匂いもします。ショートブレッドクッキーかシュガークッキーの匂いです。\r\n# 命題キー:\r\n- G — それらはジンジャースナップクッキーです\r\n- H — それらはショートブレッドクッキーです\r\n- U — それらはシュガークッキーです",
 "# A Longer Level\r\nThe `rw` tactic makes this level a cakewalk. For the redux version we're going to make this outright tedious, but this will show without a doubt that you've mastered simple propositional proofs.\\\r\n\\\r\nI suggest you finish the other redux worlds before doing this level.\\\r\n\\\r\nWe're not allowing `have`, `exact`, or `rw` for this level. It's certainly doable this way... good luck.":
 "",
 "# A Chain of Reasoning\r\nYou know Alarfil will be excited about a cake with sprinkles. Since Sybeth has just started dating Alarfil and enjoys seeing them happy, it follows that Sybeth will be excited about a cake with sprinkles.\r\n# Proposition Key:\r\n- `C` — The **C**ake has sprinkles\r\n- `A` — **A**larfil is happy\r\n- `S` — **S**ybeth is happy\r\n\r\n# Transitivity Aside\r\nWith numbers, if `a` is less than `b` and `b` is less than `c`, then you can deduce that `a` is less than `c`.\r\n$$\r\n\\cfrac{a < b\\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace  b < c}{a < c}\r\n$$\r\nThis is the transitive property of `<`. You should be able to show that this same property holds for conditionals — \"`→`\". Solving this level shows the following:\r\n$$\r\n\\cfrac{C → A\\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace  A → S}{C → S}\r\n$$\r\nThis property is so commonly useful that there exists special notation for it. **Once unlocked**, `imp_trans` has an infix operator. This looks like ≫ (which is written as “\\gg”). Example: `h1 ≫ h2`":
 "# 論理的連鎖\r\nAlarfilはスプリンクルの乗ったケーキに喜ぶでしょう。SybethとAlarfilが付き合い始めたばかりで、彼らの幸せそうな姿を見るのが楽しいので、Sybethはスプリンクルの乗ったケーキに喜ぶでしょう。\r\n# 命題キー:\r\n- `C` — ケーキにスプリンクルがかけられた\r\n- `A` — **A**larfilは嬉しい\r\n- `S` — **S**ybeth は嬉しい\r\n\r\n# ところで、推移性\r\n数の場合、`a`が `b`より小さく、かつ`b`が`c`より小さい場合、`a`が `c` より小さいと導けます。\r\n$$\r\n\\cfrac{a < b\\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace  b < c}{a < c}\r\n$$\r\nこれは`<`の推移性です。この同じ性質が論理式でも成り立つことを示すことができるはずです — \"`→`\"。 このレベルを解くと示されること：\r\n$$\r\n\\cfrac{C → A\\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace \\nobreakspace  A → S}{C → S}\r\n$$\r\nこの性質はとても汎用性が高いため、専用の表記法が用意されています。 **アンロックされれば**、`imp_trans`には接中辞演算子があります。それは ≫ (“\\gg”と書く) のように見えます。例：`h1 ≫ h2`"}
